# Issue #15: User Input Params

**GitHub Issue:** https://github.com/minouris/spafw37/issues/15

**Status:** PENDING REVIEW  
**Version:** 1.1.0  
**Branch:** feature/issue-15-user-input-params-1.1.0

---

## Table of Contents

- [Overview](#overview)
- [Success Criteria](#success-criteria)
- [Implementation Plan](#implementation-plan)
  - [Program Flow Analysis](#program-flow-analysis)
  - [Design Questions - Awaiting User Clarification](#design-questions---awaiting-user-clarification)
    - [Q1: Architecture Approach](#q1-architecture-approach)
    - [Q2: Multiple Choice Population](#q2-multiple-choice-population)
    - [Q3: Prompt Timing](#q3-prompt-timing)
    - [Q4: CLI Override Behaviour](#q4-cli-override-behaviour)
    - [Q5: Cycle Behaviour](#q5-cycle-behaviour)
    - [Q6: Validation Integration](#q6-validation-integration)
    - [Q7: User Input Mechanism](#q7-user-input-mechanism)
    - [Q8: Silent/Batch Mode](#q8-silentbatch-mode)
  - [Implementation Steps](#implementation-steps)
    - [Phase 1: Core Infrastructure](#phase-1-core-infrastructure)
    - [Phase 2: Prompt Execution](#phase-2-prompt-execution)
    - [Phase 3: Testing and Documentation](#phase-3-testing-and-documentation)
- [Further Considerations](#further-considerations)
  - [1. Design Pattern Research](#1-design-pattern-research---resolved)
  - [2. Architecture Approach Trade-offs](#2-architecture-approach-trade-offs---resolved)
  - [3. Implementation Complexity Assessment](#3-implementation-complexity-assessment---resolved)
  - [4. User Experience Considerations](#4-user-experience-considerations---resolved)
  - [5. Alternative Solutions](#5-alternative-solutions---resolved)
  - [6. Backward Compatibility and Breaking Changes](#6-backward-compatibility-and-breaking-changes---resolved)
  - [7. Testing Strategy](#7-testing-strategy---resolved)
- [Fixing Regressions](#fixing-regressions)
- [Implementation Plan Changes](#implementation-plan-changes)
- [Documentation Updates](#documentation-updates)
- [CHANGES for v1.1.0 Release](#changes-for-v110-release)

---

## Overview

Currently, spafw37 requires all parameter values to be provided via command-line arguments or configuration files. This makes the framework unsuitable for interactive workflows where users need to provide input dynamically during execution, such as confirmation prompts, selection from lists, or entering sensitive data that shouldn't appear in command history.

This feature adds interactive prompt support to the parameter system, allowing params to solicit user input at runtime. Prompts integrate with the existing parameter infrastructure, leveraging existing validation, type handling, and required param checking. The implementation uses a param-level architecture where new optional properties control prompt behaviour, keeping the feature opt-in and maintaining backward compatibility.

The solution provides an extensible design with a default handler using Python's built-in `input()` function, whilst allowing custom handlers for advanced use cases such as GUI prompts or API-based input. Prompts can be configured to appear at application start or before specific commands, with fine-grained control over repeat behaviour in cycles.

**Key architectural decisions (all resolved):**

- **Architecture approach:** Param-level properties (`PARAM_PROMPT`, `PARAM_PROMPT_HANDLER`, `PARAM_PROMPT_TIMING`, `PARAM_PROMPT_REPEAT`) extend existing param system rather than creating separate structure
- **Extensibility:** Default handler in `input_prompt.py` using `input()` function; customisable via per-param `PARAM_PROMPT_HANDLER` property or global `set_prompt_handler()` method
- **Timing control:** `PARAM_PROMPT_TIMING` property controls when prompts appear (`PROMPT_ON_START` or `PROMPT_ON_COMMAND`); `PROMPT_ON_COMMANDS` property stores list of command names when using `PROMPT_ON_COMMAND` timing; auto-population of `PROMPT_ON_COMMANDS` property from `COMMAND_REQUIRED_PARAMS`; reciprocal `COMMAND_PROMPT_PARAMS` list built automatically on commands for O(1) lookup
- **Inline definitions:** Commands can define prompt params inline in `COMMAND_PROMPT_PARAMS` using dictionary definitions, consistent with `COMMAND_REQUIRED_PARAMS`, `COMMAND_TRIGGER_PARAM`, and dependency fields (see `examples/inline_definitions_basic.py`)
- **CLI integration:** Prompts skipped entirely if param value already set via CLI; no confirmation needed
- **Cycle behaviour:** Unified timing/repeat mechanism using `PARAM_PROMPT_REPEAT` handles both regular commands and cycles
- **Validation:** Uses existing framework validation functions; validates immediately after entry with retry logic and max retry limit
- **Type handling:** Leverages existing `PARAM_TYPE` constants (`PARAM_TYPE_TEXT`, `PARAM_TYPE_NUMBER`, `PARAM_TYPE_TOGGLE`) and `PARAM_ALLOWED_VALUES` for multiple choice
- **Framework integration:** Proceed with implementation—complexity manageable, feature remains opt-in with complexity isolated behind `is_prompt_required()` helper
- **Testing approach:** Use pytest with `monkeypatch` fixture and `StringIO` for stdin mocking (compatible with Python 3.7.9, already used extensively in project)

## Success Criteria

[PENDING REVIEW - To be completed in Step 5]

## Implementation Plan

### Program Flow Analysis

#### Current Behaviour (Before Changes)

Parameters are populated exclusively from command-line arguments and configuration files. Values are set during CLI parsing in `cli.py` via `_parse_command_line()`, and required params are validated before command execution. There is no mechanism for interactive user input.

**Standard execution flow:**
1. Application starts → `run_cli()` called in `core.py`
2. CLI parsing → `_parse_command_line()` in `cli.py`
   - Tokenises command line into params and commands
   - Sets param values from CLI arguments
   - Loads config file if specified
3. Param validation → Framework validates required params exist
4. Command execution → Commands run with available param values
5. Result: All param values must be provided upfront; no interactive prompting

#### New Behaviour (After Changes)

Parameters can optionally solicit interactive user input at runtime. Prompts integrate with existing param lifecycle and respect CLI-provided values.

**With PROMPT_ON_START timing:**
1. Application starts → `run_cli()` called in `core.py`
2. CLI parsing → `_parse_command_line()` in `cli.py`
   - Tokenises command line into params and commands
   - Sets param values from CLI arguments
   - Loads config file if specified
3. **NEW:** Prompt phase → After CLI parsing, before command execution
   - Check all params for `PARAM_PROMPT` with `PROMPT_ON_START` timing
   - For each prompt param without existing value (CLI didn't set it):
     - Call prompt handler (default: `input_prompt.py` → `input()`)
     - Validate input immediately using existing validation functions
     - Retry on error up to max retry limit
     - Set param value or exit/set None based on required status
4. Param validation → Framework validates required params exist
5. Command execution → Commands run with param values (prompted or CLI)
6. Result: Users prompted for missing values after CLI parsing; CLI values prevent prompting

**With PROMPT_ON_COMMAND timing:**
1. Application starts → `run_cli()` called in `core.py`
2. CLI parsing → `_parse_command_line()` in `cli.py`
3. Param validation → Framework validates required params exist
4. Command execution begins
5. **NEW:** Before each command execution:
   - Check if command name in param's `PROMPT_ON_COMMANDS` property (list)
   - Check param's `PARAM_PROMPT_REPEAT` setting:
     - `PROMPT_REPEAT_ALWAYS`: Prompt every time (preserves previous value)
     - `PROMPT_REPEAT_IF_BLANK`: Prompt only if value is blank
     - `PROMPT_REPEAT_NEVER`: Prompt only on first occurrence
   - If should prompt and no CLI value set:
     - Call prompt handler
     - Validate input immediately
     - Retry on error up to max retry limit
   - Command executes with param value
6. Result: Users prompted immediately before commands that require values

**With CLI override:**
1. CLI parsing sets param value from `--param-name value`
2. **NEW:** Prompt phase (after CLI parsing) checks if value already set
3. If set: Skip prompt entirely (no confirmation)
4. If not set: Execute prompt as normal
5. Result: CLI arguments prevent prompting; simple and predictable (no duplicate parsing needed)

**Extensibility flow:**
1. Application defines custom prompt handler function
2. **NEW:** Calls `set_prompt_handler(custom_function)` for global override
3. **NEW:** OR sets `PARAM_PROMPT_HANDLER: custom_function` for per-param override
4. During prompt execution:
   - Check param-level `PARAM_PROMPT_HANDLER` first
   - Fall back to global handler if set
   - Fall back to default `input_prompt.py` handler
5. Result: Custom handlers replace or augment default behaviour

### Design Questions - Awaiting User Clarification

**These questions have been posted as individual GitHub comments for threaded responses:**

Implementation cannot proceed without answers to the following design questions:

**Q1: Architecture Approach** ([#issuecomment-3587791402](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791402))

Should user input params be:
- Regular params with additional properties (e.g., `PARAM_PROMPT`, `PARAM_PROMPT_TIMING`)?
- A separate structure entirely (e.g., `INPUT_PROMPTS` at command level)?
- A hybrid approach where params define what can be prompted and commands control when?

**Answer:** See [Further Consideration 2: Architecture Approach Trade-offs](#2-architecture-approach-trade-offs---resolved) - Option A (param-level approach) has been selected.

[↑ Back to top](#table-of-contents)

---

**Q2: Multiple Choice Population** ([#issuecomment-3587791428](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791428))

For multiple choice prompts, how should the list of choices be populated programmatically?
- Via a command (as mentioned in the issue: "Specify command to populate list")?
- Via a callable function in the param definition?
- Via a static list that can be updated at runtime?

If via command: How would a param specify which command to run? This would create a bidirectional dependency between params and commands that doesn't currently exist in the architecture.

**Answer:** Use static list with runtime updates via new public API method `set_allowed_values(param_name, values)`. Multiple choice uses existing `PARAM_ALLOWED_VALUES`. Commands can call this method to populate choices dynamically without creating bidirectional dependencies.

[↑ Back to top](#table-of-contents)

---

**Q3: Prompt Timing** ([#issuecomment-3587791444](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791444))

The issue mentions "at the start of a flow, or immediately before the command is executed."
- Should timing be controlled by the param definition or the command definition?
- What exactly does "immediately before command execution" mean in the context of command queues, dependencies, and phases?
- Should there be a flag on the command (as suggested in the issue)?

**Answer:** Use param-level properties for timing control, with reciprocal lists on commands for efficient lookup.

**Design:**

**Param-side constants:**

`PARAM_PROMPT_TIMING` - Controls when the prompt appears:
- `PROMPT_ON_START`: Prompts immediately after CLI parsing (before command execution)
- `PROMPT_ON_COMMAND`: Prompts before commands (command list specified in `PROMPT_ON_COMMANDS` property)

`PROMPT_ON_COMMANDS` - Property containing list of commands (only used when `PARAM_PROMPT_TIMING` is `PROMPT_ON_COMMAND`):
- List of command name strings: `['deploy', 'delete']`
- Inline command definitions: `[{COMMAND_NAME: 'deploy', ...}]`
- Mixed string/inline: `['deploy', {COMMAND_NAME: 'delete', ...}]`
- Auto-populates from `COMMAND_REQUIRED_PARAMS` if not explicitly set

`PARAM_PROMPT_REPEAT` - Controls repeat behaviour (works with `PROMPT_ON_COMMAND` timing):
- `PROMPT_REPEAT_ALWAYS`: Repeats before every command in `PROMPT_ON_COMMANDS` list. Preserves previous value.
- `PROMPT_REPEAT_IF_BLANK`: Repeats before commands in `PROMPT_ON_COMMANDS` list if the value is blank
- `PROMPT_REPEAT_NEVER`: Never repeat after the first prompt

**Command-side constant:**

`COMMAND_PROMPT_PARAMS` - List of param names that prompt before this command (built automatically during registration):
- Enables O(1) lookup: "which params need prompting before this command executes?"
- Populated from params that have this command in their `PROMPT_ON_COMMANDS` list
- Can be explicitly set with param names (string references) or inline param definitions (dictionaries)
- Inline definitions follow same pattern as `COMMAND_REQUIRED_PARAMS` for API consistency

**Reciprocal list auto-population:**
- When a param is added with `PROMPT_ON_COMMANDS`, those command names are stored on the param
- When a command is added with `COMMAND_REQUIRED_PARAMS`, framework auto-populates `PROMPT_ON_COMMANDS` for matching params (if they have `PARAM_PROMPT` and `PROMPT_ON_COMMANDS` is not explicitly set)
- When a command is added with `COMMAND_PROMPT_PARAMS`, framework processes inline definitions and establishes reciprocal relationships
- Commands build their `COMMAND_PROMPT_PARAMS` list at registration time from params that prompt before them
- This allows efficient lookup: "which params need prompting before this command executes?"

**Rationale:** Param-level approach provides fine-grained control whilst integrating with existing `COMMAND_REQUIRED_PARAMS` structure. Auto-population from `COMMAND_REQUIRED_PARAMS` reduces configuration burden. Reciprocal lists enable efficient command-side lookup without scanning all params. Inline definition support in `COMMAND_PROMPT_PARAMS` maintains API consistency with existing framework patterns.

**Breaking changes:** None (new optional properties only).

**Cross-reference:** Resolves timing aspects of Q5 (Cycle Behaviour).

[↑ Back to top](#table-of-contents)

---

**Q4: CLI Override Behaviour** ([#issuecomment-3587791457](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791457))

If a user input param can also be set on the command line:
- Should the prompt be skipped entirely if the value is provided via CLI?
- Should it display the CLI value and ask for confirmation?
- Does the behaviour differ for required vs optional params?

**Answer:** If param value is already set (via CLI), skip the prompt entirely. Params with aliases can be set by CLI handler. No confirmation needed. Simple and predictable.

[↑ Back to top](#table-of-contents)

---

**Q5: Cycle Behaviour** ([#issuecomment-3587791473](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791473))

For params in cycle commands, the issue mentions three options:
- Pop up to confirm value if set
- Silently pass if value is set
- Make prompting optional

Which behaviour is preferred? How does this interact with loop iterations (should it prompt once before the cycle, or on each iteration)?

**Answer:** Controlled by `PARAM_PROMPT_REPEAT` (see Q3).

**Design:**

Cycle behaviour is handled by the repeat property:
- `PROMPT_REPEAT_ALWAYS`: Prompts before every cycle iteration (can confirm/change value each time, preserves previous)
- `PROMPT_REPEAT_IF_BLANK`: Prompts on first iteration if blank, then uses same value for remaining iterations
- `PROMPT_REPEAT_NEVER`: Prompts once before cycle starts, uses same value for all iterations

Combined with the `PROMPT_ON_COMMANDS` property listing the cycle command name, this provides full control over cycle prompt behaviour.

**Rationale:** Unified timing/repeat mechanism handles both regular commands and cycles without special-case logic.

**Breaking changes:** None.

**Cross-reference:** See Q3 (Prompt Timing) for full timing control details.

[↑ Back to top](#table-of-contents)

---

**Q6: Validation Integration** ([#issuecomment-3587791497](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791497))

The issue states "Not included in validation, as not a command line param" but user input params would still need validation (type checking, allowed values, etc.):
- Should validation happen immediately on user input?
- Should these params participate in required param checking?
- How do they interact with the existing `PARAM_REQUIRED`, `PARAM_ALLOWED_VALUES`, etc.?

**Answer:** Use existing framework validation functions. Validate immediately after entry. Required if `PARAM_REQUIRED: True` OR in `COMMAND_REQUIRED_PARAMS`. Default handling uses bash convention `[default: value]`. Retry logic: re-prompt on error with max retry limit; behaviour on max retry depends on required status (exit if required, set `None` if optional).

[↑ Back to top](#table-of-contents)

---

**Q7: User Input Mechanism** ([#issuecomment-3587791517](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791517))

What should the user input mechanism look like?
- Text: Use Python's `input()` function?
- Boolean: Accept yes/no, y/n, true/false?
- Number: Validate numeric input with retry on error?
- Multiple choice: Display numbered list and accept number input?
- Error handling: Retry on invalid input, abort, or use default?

**Answer:** See [Further Consideration 1: Design Pattern Research](#1-design-pattern-research---resolved) - Use Python's built-in `input()` function as the default handler, with extensibility support.

**Implementation:**
- Default prompt handler implemented in new file `input_prompt.py` using `input()` function
- Extensible via `PARAM_PROMPT_HANDLER` property (per-param override) or `set_prompt_handler()` method (global override)
- **Text:** Use `input()` with string return value
- **Boolean:** Accept yes/no, y/n, true/false with case-insensitive matching
- **Number:** Use `input()` with int() or float() conversion, retry on ValueError
- **Multiple choice:** Display numbered list, accept either number or text value
- **Error handling:** Retry on invalid input with clear error message

**Rationale:** Python's built-in `input()` function is simple, requires no dependencies, works on all platforms, and is what most Python CLI tools use. Extensible design allows custom handlers for advanced use cases (GUI prompts, API-based input, etc.).

[↑ Back to top](#table-of-contents)

---

**Q8: Silent/Batch Mode** ([#issuecomment-3587791532](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791532))

How should prompts interact with existing framework flags?
- Should prompts be suppressed with `--silent`?
- How to disable prompts for automated scripts/batch mode?
- Should there be a `--no-prompts` flag?

**Answer:** Interactive prompts are incompatible with batch/automated execution by design. If a required param with `PARAM_PROMPT` is not provided via CLI or config, the existing "missing required param" validation error will occur naturally. No special handling needed.

**Note:** `--silent` suppresses console logging output, not interactive prompts. Some prompt timing/repeat configurations will simply not work in automated/batch scenarios - this is expected behaviour.

[↑ Back to top](#table-of-contents)

---

### Implementation Steps

Now that all design decisions are resolved, implementation follows a test-driven approach where each component is tested as it's built. Tests are interleaved with implementation to ensure incremental validation.

#### Phase 1: Core Infrastructure

**Step 1: Add prompt constants**

**Files:** `src/spafw37/constants/param.py`, `src/spafw37/constants/command.py`

Add new constants for prompt configuration in param.py and command.py modules.

**Implementation order:**

1. Add param-level prompt property constants to `param.py`
2. Add timing control constants to `param.py`
3. Add repeat behaviour constants to `param.py`
4. Add command reciprocal list constant to `command.py`
5. Verify no constant value collisions within each module

**Tests for Step 1: Prompt constants**

Module-level imports for `tests/test_constants.py`:
```python
# Module-level imports for tests/test_constants.py
from spafw37.constants import param, command
```

**Code 1.1.1: Param prompt property constants**

```python
# Block 1.1.1: Add to src/spafw37/constants/param.py
PARAM_PROMPT = 'prompt'  # Prompt text to display to user
PARAM_PROMPT_HANDLER = 'prompt-handler'  # Custom handler function for this param
PARAM_PROMPT_TIMING = 'prompt-timing'  # When to display prompt (constant or list)
PARAM_PROMPT_REPEAT = 'prompt-repeat'  # Repeat behaviour for cycles/multiple commands
```

**Test 1.1.2: Tests for param prompt constants definition**

```gherkin
Scenario: All PARAM_PROMPT* constants are defined in param constants module
  Given the param constants module is imported
  When checking for PARAM_PROMPT, PARAM_PROMPT_HANDLER, PARAM_PROMPT_TIMING, PARAM_PROMPT_REPEAT
  Then all constants are defined as string keys
  And each constant has a unique value
  
  # Tests: Constant definition completeness
  # Validates: All param-level prompt properties have corresponding constants
```

```python
# Test 1.1.2: Add to tests/test_constants.py
def test_param_prompt_constants_exist():
    """Test that all PARAM_PROMPT* constants required for prompt configuration are defined.
    
    This test verifies that PARAM_PROMPT, PARAM_PROMPT_HANDLER, PARAM_PROMPT_TIMING,
    and PARAM_PROMPT_REPEAT constants exist as strings with unique values.
    This behaviour is expected because these constants form the core vocabulary for
    configuring interactive prompts on parameters and must be available for param definitions."""
    # Block 1.1.2.1: Check all four prompt property constants exist
    assert hasattr(param, 'PARAM_PROMPT'), "PARAM_PROMPT constant missing"
    assert hasattr(param, 'PARAM_PROMPT_HANDLER'), "PARAM_PROMPT_HANDLER constant missing"
    assert hasattr(param, 'PARAM_PROMPT_TIMING'), "PARAM_PROMPT_TIMING constant missing"
    assert hasattr(param, 'PARAM_PROMPT_REPEAT'), "PARAM_PROMPT_REPEAT constant missing"
    
    # Block 1.1.2.2: Verify all are strings (required for dict keys)
    assert isinstance(param.PARAM_PROMPT, str), "PARAM_PROMPT must be string"
    assert isinstance(param.PARAM_PROMPT_HANDLER, str), "PARAM_PROMPT_HANDLER must be string"
    assert isinstance(param.PARAM_PROMPT_TIMING, str), "PARAM_PROMPT_TIMING must be string"
    assert isinstance(param.PARAM_PROMPT_REPEAT, str), "PARAM_PROMPT_REPEAT must be string"
    
    # Block 1.1.2.3: Verify all values are unique
    constant_values = [
        param.PARAM_PROMPT,
        param.PARAM_PROMPT_HANDLER,
        param.PARAM_PROMPT_TIMING,
        param.PARAM_PROMPT_REPEAT
    ]
    assert len(constant_values) == len(set(constant_values)), "Constant values must be unique"
```

**Code 1.2.1: Timing control constants**

```python
# Block 1.2.1: Add to src/spafw37/constants/param.py
PROMPT_ON_START = 'on-start'  # Prompt after CLI parsing, before command execution
PROMPT_ON_COMMAND = 'on-command'  # Prompt before commands (list in PROMPT_ON_COMMANDS property)
```

**Test 1.2.2: Tests for timing control constants**

```gherkin
Scenario: All PROMPT_* timing constants are defined with correct values
  Given the param constants module is imported
  When checking for PROMPT_ON_START and PROMPT_ON_COMMAND
  Then both constants are defined
  And PROMPT_ON_START is a string constant
  And PROMPT_ON_COMMAND is a string constant
  And values are distinct from each other
  
  # Tests: Timing constant definition
  # Validates: Timing options have proper constant values for comparison logic
```

```python
# Test 1.2.2: Add to tests/test_constants.py
def test_prompt_timing_constants_exist():
    """Test that timing control constants PROMPT_ON_START and PROMPT_ON_COMMAND are defined.
    
    This test verifies both constants exist as strings with distinct values for use in
    PARAM_PROMPT_TIMING configurations.
    This behaviour is expected because timing options require proper constants for comparison
    logic throughout the codebase to determine when prompts should appear."""
    # Block 1.2.2.1: Check both timing constants exist
    assert hasattr(param, 'PROMPT_ON_START'), "PROMPT_ON_START constant missing"
    assert hasattr(param, 'PROMPT_ON_COMMAND'), "PROMPT_ON_COMMAND constant missing"
    
    # Block 1.2.2.2: Verify both are strings
    assert isinstance(param.PROMPT_ON_START, str), "PROMPT_ON_START must be string"
    assert isinstance(param.PROMPT_ON_COMMAND, str), "PROMPT_ON_COMMAND must be string"
    
    # Block 1.2.2.3: Verify values are distinct
    assert param.PROMPT_ON_START != param.PROMPT_ON_COMMAND, "Timing constants must have distinct values"
```

**Code 1.3.1: Repeat behaviour constants**

```python
# Block 1.3.1: Add to src/spafw37/constants/param.py
PROMPT_REPEAT_ALWAYS = 'always'  # Prompt every time, preserve previous value
PROMPT_REPEAT_IF_BLANK = 'if-blank'  # Prompt only if value is blank
PROMPT_REPEAT_NEVER = 'never'  # Never repeat after first prompt
```

**Test 1.3.2: Tests for repeat behaviour constants**

```gherkin
Scenario: All PROMPT_REPEAT_* constants are defined with distinct values
  Given the param constants module is imported
  When checking for PROMPT_REPEAT_ALWAYS, PROMPT_REPEAT_IF_BLANK, PROMPT_REPEAT_NEVER
  Then all three constants are defined
  And each constant is a string
  And all three values are unique
  
  # Tests: Repeat behaviour constant definition
  # Validates: All repeat options have proper constants for cycle control logic
```

```python
# Test 1.3.2: Add to tests/test_constants.py
def test_prompt_repeat_constants_exist():
    """Test that all PROMPT_REPEAT_* constants controlling cycle behaviour are defined.
    
    This test verifies PROMPT_REPEAT_ALWAYS, PROMPT_REPEAT_IF_BLANK, and PROMPT_REPEAT_NEVER
    constants exist as strings with unique values.
    This behaviour is expected because repeat options must have proper constants for cycle
    control logic to determine whether prompts should repeat on subsequent iterations."""
    # Block 1.3.2.1: Check all three repeat constants exist
    assert hasattr(param, 'PROMPT_REPEAT_ALWAYS'), "PROMPT_REPEAT_ALWAYS constant missing"
    assert hasattr(param, 'PROMPT_REPEAT_IF_BLANK'), "PROMPT_REPEAT_IF_BLANK constant missing"
    assert hasattr(param, 'PROMPT_REPEAT_NEVER'), "PROMPT_REPEAT_NEVER constant missing"
    
    # Block 1.3.2.2: Verify all are strings
    assert isinstance(param.PROMPT_REPEAT_ALWAYS, str), "PROMPT_REPEAT_ALWAYS must be string"
    assert isinstance(param.PROMPT_REPEAT_IF_BLANK, str), "PROMPT_REPEAT_IF_BLANK must be string"
    assert isinstance(param.PROMPT_REPEAT_NEVER, str), "PROMPT_REPEAT_NEVER must be string"
    
    # Block 1.3.2.3: Verify all three values are unique
    repeat_values = [
        param.PROMPT_REPEAT_ALWAYS,
        param.PROMPT_REPEAT_IF_BLANK,
        param.PROMPT_REPEAT_NEVER
    ]
    assert len(repeat_values) == len(set(repeat_values)), "Repeat constant values must be unique"
```

**Code 1.4.1: Command reciprocal list constant**

```python
# Block 1.4.1: Add to src/spafw37/constants/command.py
COMMAND_PROMPT_PARAMS = 'prompt-params'  # List of param names that prompt before this command
```

**Test 1.4.2: Tests for command prompt params constant**

```gherkin
Scenario: COMMAND_PROMPT_PARAMS constant defined in command constants module
  Given the command constants module is imported
  When checking for COMMAND_PROMPT_PARAMS
  Then the constant is defined as a string key
  And the value is unique within command constants
  
  # Tests: Command reciprocal list constant
  # Validates: Commands can store list of params that prompt before them
```

```python
# Test 1.4.2: Add to tests/test_constants.py
def test_command_prompt_params_constant_exists():
    """Test that COMMAND_PROMPT_PARAMS constant is defined in the command constants module.
    
    This test verifies the constant exists as a string key suitable for use as a dictionary
    property on command definitions.
    This behaviour is expected because commands need to store lists of parameter names that
    should prompt before execution, enabling O(1) lookup during command execution."""
    # Block 1.4.2.1: Check constant exists
    assert hasattr(command, 'COMMAND_PROMPT_PARAMS'), "COMMAND_PROMPT_PARAMS constant missing"
    
    # Block 1.4.2.2: Verify it's a string (required for dict key)
    assert isinstance(command.COMMAND_PROMPT_PARAMS, str), "COMMAND_PROMPT_PARAMS must be string"
```

[↑ Back to top](#table-of-contents)

---

**Step 2: Create default input handler module**

**File:** `src/spafw37/input_prompt.py`

Implement default prompt handler using Python's `input()` function with support for text, number, toggle, and multiple choice inputs.

**Implementation order:**

1. Import required constants from `constants/param.py`
2. Implement prompt text formatting with default value display
3. Implement text input handler (simplest case)
4. Implement number input handler with int/float conversion
5. Implement toggle input handler with multiple accepted formats
6. Implement multiple choice handler with numbered list display
7. Add EOF handling for non-interactive environments

**Code 2.1.1: Module docstring and imports**

```python
# Block 2.1.1: Create new file src/spafw37/input_prompt.py
"""Default interactive prompt handler using Python's built-in input() function.

This module provides the default implementation for soliciting user input
at runtime for params configured with PARAM_PROMPT. The handler supports
text, number, toggle, and multiple choice inputs with proper type conversion
and default value handling.
"""

from spafw37.constants.param import (
    PARAM_NAME,
    PARAM_PROMPT,
    PARAM_DEFAULT,
    PARAM_TYPE,
    PARAM_TYPE_TEXT,
    PARAM_TYPE_NUMBER,
    PARAM_TYPE_TOGGLE,
    PARAM_ALLOWED_VALUES
)
```

**Code 2.2.1: Format prompt text with default**

```python
# Block 2.2.1: Add to src/spafw37/input_prompt.py
def _format_prompt_text(param_def):
    """Format prompt text with default value in bash convention.
    
    Args:
        param_def: Parameter definition dictionary.
        
    Returns:
        Formatted prompt string with [default: value] if default exists.
    """
    # Block 2.2.1.1: Get prompt text from param definition
    prompt_text = param_def.get(PARAM_PROMPT, 'Enter value')
    
    # Block 2.2.1.2: Add default value indicator if present
    default_value = param_def.get(PARAM_DEFAULT)
    if default_value is not None:
        prompt_text = "{0} [default: {1}]".format(prompt_text, default_value)
    
    # Block 2.2.1.3: Add trailing space for user input
    return "{0}: ".format(prompt_text)
```

Module-level imports for `tests/test_input_prompt.py`:
```python
# Module-level imports for tests/test_input_prompt.py
from io import StringIO
import pytest
from spafw37 import input_prompt
from spafw37.constants.param import (
    PARAM_NAME,
    PARAM_PROMPT,
    PARAM_DEFAULT,
    PARAM_TYPE,
    PARAM_TYPE_TEXT,
    PARAM_TYPE_NUMBER,
    PARAM_TYPE_TOGGLE,
    PARAM_ALLOWED_VALUES
)
```

**Test 2.2.2: Tests for prompt text formatting with default value**

```gherkin
Scenario: Default value shown in prompt text using bash convention
  Given a param with PARAM_DEFAULT "example_default"
  When prompt text is formatted
  Then prompt includes "[default: example_default]"
  And format follows bash convention style
  
  # Tests: Default value display formatting
  # Validates: Users see what default will be used if they press enter
```

```python
# Test 2.2.2: Add to tests/test_input_prompt.py
def test_format_prompt_text_with_default():
    """Test that prompt text formatting includes default values using bash convention.
    
    This test verifies that when a parameter has PARAM_DEFAULT set, the formatted prompt
    displays "[default: value]" following standard bash/Unix prompt conventions.
    This behaviour is expected because users need clear indication of what value will be
    used if they press Enter without typing, matching familiar command-line tool patterns."""
    # Block 2.2.2.1: Create param with default value
    param_def = {
        PARAM_DEFAULT: 'example_default',
        PARAM_PROMPT: 'Enter text'
    }
    
    # Block 2.2.2.2: Format prompt text
    formatted_text = input_prompt._format_prompt_text(param_def)
    
    # Block 2.2.2.3: Verify bash convention format
    assert '[default: example_default]' in formatted_text, "Default value not displayed"
    assert formatted_text == 'Enter text [default: example_default]: ', "Format incorrect"
```

**Code 2.3.1: Handle text input**

```python
# Block 2.3.1: Add to src/spafw37/input_prompt.py
def _handle_text_input(param_def, user_input):
    """Handle text input type (no conversion needed).
    
    Args:
        param_def: Parameter definition dictionary.
        user_input: Raw user input string.
        
    Returns:
        User input string or default value if blank.
    """
    # Block 2.3.1.1: Return user input if not blank
    if user_input.strip():
        return user_input.strip()
    
    # Block 2.3.1.2: Return default if blank input
    return param_def.get(PARAM_DEFAULT)
```

**Test 2.3.2: Tests for text input handling**

```gherkin
Scenario: Text input handler returns user-entered string
  Given a param with PARAM_TYPE_TEXT and no default value
  And stdin is mocked with StringIO("test value\n")
  When prompt_for_value() is called
  Then the function returns "test value"
  
  # Tests: Basic text input handling with input() function
  # Validates: String input is captured and returned correctly
```

```python
# Test 2.3.2: Add to tests/test_input_prompt.py
def test_prompt_text_input_returns_string(monkeypatch):
    """Test that the default prompt handler captures plain text input from users.
    
    This test verifies that when stdin is mocked with StringIO containing "test value",
    the prompt_for_value() function returns exactly that string without modification.
    This behaviour is expected because text parameters are the simplest type and should
    return user input verbatim, establishing the foundation for all other input types."""
    # Block 2.3.2.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_TEXT, PARAM_NAME
    
    # Block 2.3.2.2: Create param definition for text input
    param_def = {
        PARAM_NAME: 'test_param',
        PARAM_TYPE: PARAM_TYPE_TEXT
    }
    
    # Block 2.3.2.3: Mock stdin with test input
    mock_stdin = StringIO("test value\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.3.2.4: Call prompt handler
    user_value = input_prompt.prompt_for_value(param_def)
    
    # Block 2.3.2.5: Verify returned value
    assert user_value == "test value", "Expected 'test value', got '{0}'".format(user_value)
```

**Test 2.3.3: Tests for blank input with default value**

```gherkin
Scenario: Blank input with default value returns the default
  Given a param with PARAM_TYPE_TEXT and PARAM_DEFAULT "default_value"
  And stdin is mocked with StringIO("\n")
  When prompt_for_value() is called
  Then the function returns "default_value"
  
  # Tests: Default value handling for text input
  # Validates: Blank input selects default using bash convention
```

```python
# Test 2.3.3: Add to tests/test_input_prompt.py
def test_prompt_text_with_default_blank_input(monkeypatch):
    """Test that pressing Enter without typing selects the default value automatically.
    
    This test verifies that when stdin is mocked with just a newline character and
    PARAM_DEFAULT is set, the function returns the default value.
    This behaviour is expected because the bash convention of showing "[default: value]"
    implies that blank input (just pressing Enter) will use that default value."""
    # Block 2.3.3.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_TEXT, PARAM_DEFAULT
    
    # Block 2.3.3.2: Create param with default value
    param_def = {
        PARAM_TYPE: PARAM_TYPE_TEXT,
        PARAM_DEFAULT: 'default_value'
    }
    
    # Block 2.3.3.3: Mock stdin with blank input (just newline)
    mock_stdin = StringIO("\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.3.3.4: Call prompt handler
    user_value = input_prompt.prompt_for_value(param_def)
    
    # Block 2.3.3.5: Verify default value returned
    assert user_value == 'default_value', "Expected 'default_value', got '{0}'".format(user_value)
```

**Code 2.4.1: Handle number input**

```python
# Block 2.4.1: Add to src/spafw37/input_prompt.py
def _handle_number_input(param_def, user_input):
    """Handle number input with int/float conversion.
    
    Args:
        param_def: Parameter definition dictionary.
        user_input: Raw user input string.
        
    Returns:
        Converted number (int or float) or default value if blank.
        
    Raises:
        ValueError: If input cannot be converted to number.
    """
    # Block 2.4.1.1: Return default if blank input
    if not user_input.strip():
        return param_def.get(PARAM_DEFAULT)
    
    # Block 2.4.1.2: Try integer conversion first
    try:
        return int(user_input)
    except ValueError:
        pass
    
    # Block 2.4.1.3: Fall back to float conversion
    return float(user_input)
```

**Test 2.4.2: Tests for number integer input conversion**

```gherkin
Scenario: Valid integer input converted correctly
  Given a param with PARAM_TYPE_NUMBER
  And stdin is mocked with StringIO("42\n")
  When prompt_for_value() is called
  Then the function returns 42 as integer
  And no conversion errors occur
  
  # Tests: Number input with integer conversion
  # Validates: Integer strings converted to int type
```

```python
# Test 2.4.2: Add to tests/test_input_prompt.py
def test_prompt_number_integer_valid(monkeypatch):
    """Test that integer input is correctly converted to int type for numeric parameters.
    
    This test verifies that when a user enters "42" for a PARAM_TYPE_NUMBER parameter,
    the handler converts it to the integer 42 (not string or float).
    This behaviour is expected because integer input (no decimal point) should be
    converted using int() for proper numeric operations, counters, and array indices."""
    # Block 2.4.2.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_NUMBER, PARAM_PROMPT
    
    # Block 2.4.2.2: Create param definition for number input
    param_def = {
        PARAM_PROMPT: 'Enter number',
        PARAM_TYPE: PARAM_TYPE_NUMBER
    }
    
    # Block 2.4.2.3: Mock stdin with integer input
    mock_stdin = StringIO("42\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.4.2.4: Call prompt handler
    result_value = input_prompt.prompt_for_value(param_def)
    
    # Block 2.4.2.5: Verify integer type and value
    assert isinstance(result_value, int), "Expected int type, got {0}".format(type(result_value))
    assert result_value == 42, "Expected 42, got {0}".format(result_value)
```

**Test 2.4.3: Tests for number float input conversion**

```gherkin
Scenario: Valid float input converted correctly
  Given a param with PARAM_TYPE_NUMBER  
  And stdin is mocked with StringIO("3.14\n")
  When prompt_for_value() is called
  Then the function returns 3.14 as float
  And no conversion errors occur
  
  # Tests: Number input with float conversion
  # Validates: Float strings converted to float type
```

```python
# Test 2.4.3: Add to tests/test_input_prompt.py
def test_prompt_number_float_valid(monkeypatch):
    """Test that floating-point input is correctly converted to float type for numeric parameters.
    
    This test verifies that when a user enters "3.14" for a PARAM_TYPE_NUMBER parameter,
    the handler converts it to the float 3.14 (not string or integer).
    This behaviour is expected because float input (contains decimal point) should be
    converted using float() for precise measurements, percentages, and scientific values."""
    # Block 2.4.3.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_NUMBER, PARAM_PROMPT
    
    # Block 2.4.3.2: Create param definition for number input
    param_def = {
        PARAM_PROMPT: 'Enter number',
        PARAM_TYPE: PARAM_TYPE_NUMBER
    }
    
    # Block 2.4.3.3: Mock stdin with float input
    mock_stdin = StringIO("3.14\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.4.3.4: Call prompt handler
    result_value = input_prompt.prompt_for_value(param_def)
    
    # Block 2.4.3.5: Verify float type and value
    assert isinstance(result_value, float), "Expected float type, got {0}".format(type(result_value))
    assert result_value == 3.14, "Expected 3.14, got {0}".format(result_value)
```

**Test 2.4.4: Tests for number invalid input validation**

```gherkin
Scenario: Invalid number input raises ValueError
  Given a param with PARAM_TYPE_NUMBER
  And stdin is mocked with StringIO("not_a_number\n")
  When prompt_for_value() is called
  Then ValueError is raised
  And error message indicates conversion failure
  
  # Tests: Number input validation
  # Validates: Non-numeric input rejected with clear error
```

```python
# Test 2.4.4: Add to tests/test_input_prompt.py
def test_prompt_number_invalid_raises_error(monkeypatch):
    """Test that non-numeric input raises ValueError for numeric parameters.
    
    This test verifies that when a user enters "not_a_number" for a PARAM_TYPE_NUMBER parameter,
    the handler raises ValueError rather than returning invalid data.
    This behaviour is expected because type conversion failures must be caught and reported
    clearly, enabling retry logic at higher levels to prompt the user again."""
    # Block 2.4.4.1: Import required modules
    from io import StringIO
    import pytest
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_NUMBER, PARAM_PROMPT
    
    # Block 2.4.4.2: Create param definition for number input
    param_def = {
        PARAM_PROMPT: 'Enter number',
        PARAM_TYPE: PARAM_TYPE_NUMBER
    }
    
    # Block 2.4.4.3: Mock stdin with invalid input
    mock_stdin = StringIO("not_a_number\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.4.4.4: Verify ValueError raised
    with pytest.raises(ValueError):
        input_prompt.prompt_for_value(param_def)
```

**Code 2.5.1: Handle toggle input**

```python
# Block 2.5.1: Add to src/spafw37/input_prompt.py
def _handle_toggle_input(param_def, user_input):
    """Handle toggle (boolean) input with multiple accepted formats.
    
    Accepts: y/yes/true (case-insensitive) for True
             n/no/false (case-insensitive) for False
    
    Args:
        param_def: Parameter definition dictionary.
        user_input: Raw user input string.
        
    Returns:
        Boolean value or default value if blank.
        
    Raises:
        ValueError: If input is not a recognized boolean format.
    """
    # Block 2.5.1.1: Return default if blank input
    if not user_input.strip():
        return param_def.get(PARAM_DEFAULT)
    
    # Block 2.5.1.2: Normalize input to lowercase for comparison
    normalized_input = user_input.strip().lower()
    
    # Block 2.5.1.3: Check affirmative values
    if normalized_input in ('y', 'yes', 'true'):
        return True
    
    # Block 2.5.1.4: Check negative values
    if normalized_input in ('n', 'no', 'false'):
        return False
    
    # Block 2.5.1.5: Raise error for unrecognized format
    raise ValueError("Expected y/yes/true or n/no/false")
```

**Test 2.5.2: Tests for toggle affirmative input variations**

```gherkin
Scenario: Toggle input accepts multiple affirmative formats
  Given a param with PARAM_TYPE_TOGGLE
  And stdin provides "y", "Y", "yes", "YES", "true", "True" in sequence
  When prompt_for_value() is called for each input
  Then all return True boolean value
  And case-insensitive matching works correctly
  
  # Tests: Toggle input affirmative value recognition
  # Validates: Multiple formats accepted for true/yes values
```

```python
# Test 2.5.2: Add to tests/test_input_prompt.py
def test_prompt_toggle_yes_variations(monkeypatch):
    """Test that toggle parameters accept multiple affirmative formats with case-insensitive matching.
    
    This test verifies that inputs "y", "Y", "yes", "YES", "true", and "True" all return
    the Python boolean True for PARAM_TYPE_TOGGLE parameters.
    This behaviour is expected because providing flexible, user-friendly input options
    improves usability rather than forcing users to remember exact format requirements."""
    # Block 2.5.2.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_TOGGLE, PARAM_PROMPT
    
    # Block 2.5.2.2: Create param definition for toggle input
    param_def = {
        PARAM_PROMPT: 'Confirm?',
        PARAM_TYPE: PARAM_TYPE_TOGGLE
    }
    
    # Block 2.5.2.3: Test all affirmative variations
    affirmative_inputs = ['y', 'Y', 'yes', 'YES', 'true', 'True']
    for test_input in affirmative_inputs:
        mock_stdin = StringIO("{0}\n".format(test_input))
        monkeypatch.setattr('sys.stdin', mock_stdin)
        result_value = input_prompt.prompt_for_value(param_def)
        assert result_value is True, "Input '{0}' should return True".format(test_input)
```

**Test 2.5.3: Tests for toggle negative input variations**

```gherkin
Scenario: Toggle input accepts multiple negative formats
  Given a param with PARAM_TYPE_TOGGLE
  And stdin provides "n", "N", "no", "NO", "false", "False" in sequence  
  When prompt_for_value() is called for each input
  Then all return False boolean value
  And case-insensitive matching works correctly
  
  # Tests: Toggle input negative value recognition
  # Validates: Multiple formats accepted for false/no values
```

```python
# Test 2.5.3: Add to tests/test_input_prompt.py
def test_prompt_toggle_no_variations(monkeypatch):
    """Test that toggle parameters accept multiple negative formats with case-insensitive matching.
    
    This test verifies that inputs "n", "N", "no", "NO", "false", and "False" all return
    the Python boolean False for PARAM_TYPE_TOGGLE parameters.
    This behaviour is expected because comprehensive support for common negative variations
    provides a complete and intuitive toggle input experience."""
    # Block 2.5.3.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_TOGGLE, PARAM_PROMPT
    
    # Block 2.5.3.2: Create param definition for toggle input
    param_def = {
        PARAM_PROMPT: 'Confirm?',
        PARAM_TYPE: PARAM_TYPE_TOGGLE
    }
    
    # Block 2.5.3.3: Test all negative variations
    negative_inputs = ['n', 'N', 'no', 'NO', 'false', 'False']
    for test_input in negative_inputs:
        mock_stdin = StringIO("{0}\n".format(test_input))
        monkeypatch.setattr('sys.stdin', mock_stdin)
        result_value = input_prompt.prompt_for_value(param_def)
        assert result_value is False, "Input '{0}' should return False".format(test_input)
```

**Test 2.5.4: Tests for toggle invalid input validation**

```gherkin
Scenario: Invalid toggle input raises ValueError
  Given a param with PARAM_TYPE_TOGGLE
  And stdin is mocked with StringIO("maybe\n")
  When prompt_for_value() is called
  Then ValueError is raised
  And error message indicates expected formats
  
  # Tests: Toggle input validation
  # Validates: Unrecognized input rejected with helpful error
```

```python
# Test 2.5.4: Add to tests/test_input_prompt.py
def test_prompt_toggle_invalid_raises_error(monkeypatch):
    """Test that unrecognized input raises ValueError for toggle parameters.
    
    This test verifies that when a user enters "maybe" for a PARAM_TYPE_TOGGLE parameter,
    the handler raises ValueError with a clear message about expected formats.
    This behaviour is expected because ambiguous or invalid input must be rejected,
    enabling retry logic to prompt the user again with guidance on valid options."""
    # Block 2.5.4.1: Import required modules
    from io import StringIO
    import pytest
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_TOGGLE, PARAM_PROMPT
    
    # Block 2.5.4.2: Create param definition for toggle input
    param_def = {
        PARAM_PROMPT: 'Confirm?',
        PARAM_TYPE: PARAM_TYPE_TOGGLE
    }
    
    # Block 2.5.4.3: Mock stdin with invalid input
    mock_stdin = StringIO("maybe\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.5.4.4: Verify ValueError raised with helpful message
    with pytest.raises(ValueError, match="Expected y/yes/true or n/no/false"):
        input_prompt.prompt_for_value(param_def)
```

**Code 2.6.1: Handle multiple choice input**

```python
# Block 2.6.1: Add to src/spafw37/input_prompt.py
def _handle_multiple_choice_input(param_def, user_input, allowed_values):
    """Handle multiple choice input with numeric or text selection.
    
    Args:
        param_def: Parameter definition dictionary.
        user_input: Raw user input string.
        allowed_values: List of allowed string values.
        
    Returns:
        Selected value from allowed_values or default if blank.
        
    Raises:
        ValueError: If input is not valid selection (number or text).
    """
    # Block 2.6.1.1: Return default if blank input
    if not user_input.strip():
        return param_def.get(PARAM_DEFAULT)
    
    # Block 2.6.1.2: Try numeric selection first (1-indexed)
    try:
        selection_index = int(user_input) - 1
        if 0 <= selection_index < len(allowed_values):
            return allowed_values[selection_index]
    except ValueError:
        pass
    
    # Block 2.6.1.3: Try exact text match
    user_input_stripped = user_input.strip()
    if user_input_stripped in allowed_values:
        return user_input_stripped
    
    # Block 2.6.1.4: Raise error for invalid selection
    raise ValueError("Invalid selection. Enter number or exact text value")
```

**Code 2.7.1: Display multiple choice options**

```python
# Block 2.7.1: Add to src/spafw37/input_prompt.py
def _display_multiple_choice_options(allowed_values):
    """Display numbered list of multiple choice options.
    
    Args:
        allowed_values: List of allowed string values to display.
    """
    # Block 2.7.1.1: Display each option with 1-indexed number
    for option_index, option_value in enumerate(allowed_values, start=1):
        print("{0}. {1}".format(option_index, option_value))
```

**Test 2.6.2: Tests for multiple choice selection by number**

```gherkin
Scenario: Multiple choice selection by number works correctly
  Given a param with PARAM_ALLOWED_VALUES ["option1", "option2", "option3"]
  And stdin is mocked with StringIO("2\n")
  When prompt_for_value() is called
  Then numbered list displayed: "1. option1\n2. option2\n3. option3"
  And the function returns "option2"
  
  # Tests: Multiple choice selection by index number
  # Validates: Users can select by entering list number
```

```python
# Test 2.6.2: Add to tests/test_input_prompt.py
def test_prompt_multiple_choice_by_number(monkeypatch, capsys):
    """Test that users can select from multiple choice options by entering the numeric index.
    
    This test verifies that when PARAM_ALLOWED_VALUES contains ["red", "green", "blue"]
    and the user enters "2", the handler returns "green" (the second option).
    This behaviour is expected because numbered selection provides an efficient interface
    where users can type a single digit instead of the full option text."""
    # Block 2.6.2.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_PROMPT, PARAM_ALLOWED_VALUES
    
    # Block 2.6.2.2: Create param with allowed values
    param_def = {
        PARAM_PROMPT: 'Select option',
        PARAM_ALLOWED_VALUES: ['red', 'green', 'blue']
    }
    
    # Block 2.6.2.3: Mock stdin with numeric selection
    mock_stdin = StringIO("2\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.6.2.4: Call prompt handler
    selected_value = input_prompt.prompt_for_value(param_def)
    
    # Block 2.6.2.5: Verify correct option selected
    assert selected_value == 'green', "Expected 'green', got '{0}'".format(selected_value)
    
    # Block 2.6.2.6: Verify numbered list was displayed
    captured_output = capsys.readouterr()
    assert '1. red' in captured_output.out, "Option 1 not displayed"
    assert '2. green' in captured_output.out, "Option 2 not displayed"
    assert '3. blue' in captured_output.out, "Option 3 not displayed"
```

**Test 2.6.3: Tests for multiple choice selection by exact text**

```gherkin
Scenario: Multiple choice selection by exact text works correctly
  Given a param with PARAM_ALLOWED_VALUES ["red", "green", "blue"]
  And stdin is mocked with StringIO("green\n")
  When prompt_for_value() is called
  Then the function returns "green"
  And selection matches exact text from allowed values
  
  # Tests: Multiple choice selection by typing exact value
  # Validates: Users can select by entering the text value directly
```

```python
# Test 2.6.3: Add to tests/test_input_prompt.py
def test_prompt_multiple_choice_by_text(monkeypatch):
    """Test that users can select from multiple choice options by entering the exact text value.
    
    This test verifies that when PARAM_ALLOWED_VALUES contains ["red", "green", "blue"]
    and the user enters "green", the handler returns "green" directly.
    This behaviour is expected because some users prefer typing the full option name
    rather than remembering numeric indices, providing flexible selection methods."""
    # Block 2.6.3.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_PROMPT, PARAM_ALLOWED_VALUES
    
    # Block 2.6.3.2: Create param with allowed values
    param_def = {
        PARAM_PROMPT: 'Select colour',
        PARAM_ALLOWED_VALUES: ['red', 'green', 'blue']
    }
    
    # Block 2.6.3.3: Mock stdin with text selection
    mock_stdin = StringIO("green\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.6.3.4: Call prompt handler
    selected_value = input_prompt.prompt_for_value(param_def)
    
    # Block 2.6.3.5: Verify correct text match
    assert selected_value == 'green', "Expected 'green', got '{0}'".format(selected_value)
```

**Test 2.6.4: Tests for multiple choice invalid selection validation**

```gherkin
Scenario: Invalid multiple choice selection raises ValueError
  Given a param with PARAM_ALLOWED_VALUES ["red", "green", "blue"]
  And stdin is mocked with StringIO("yellow\n")
  When prompt_for_value() is called
  Then ValueError is raised
  And error message indicates invalid selection
  
  # Tests: Multiple choice validation
  # Validates: Invalid selections rejected with clear error
```

```python
# Test 2.6.4: Add to tests/test_input_prompt.py
def test_prompt_multiple_choice_invalid_selection(monkeypatch):
    """Test that invalid selections raise ValueError for multiple choice parameters.
    
    This test verifies that when the user enters "yellow" for options ["red", "green", "blue"],
    the handler raises ValueError with a message about valid selection methods.
    This behaviour is expected because only values in PARAM_ALLOWED_VALUES or their indices
    are valid, and invalid selections must be rejected to enable retry logic."""
    # Block 2.6.4.1: Import required modules
    from io import StringIO
    import pytest
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_PROMPT, PARAM_ALLOWED_VALUES
    
    # Block 2.6.4.2: Create param with allowed values
    param_def = {
        PARAM_PROMPT: 'Select colour',
        PARAM_ALLOWED_VALUES: ['red', 'green', 'blue']
    }
    
    # Block 2.6.4.3: Mock stdin with invalid selection
    mock_stdin = StringIO("yellow\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.6.4.4: Verify ValueError raised
    with pytest.raises(ValueError, match="Invalid selection"):
        input_prompt.prompt_for_value(param_def)
```

**Code 2.8.1: Main prompt handler function**

```python
# Block 2.8.1: Add to src/spafw37/input_prompt.py
def prompt_for_value(param_def):
    """Main prompt handler using Python's built-in input() function.
    
    Prompts user for input based on param type and configuration.
    Handles text, number, toggle, and multiple choice inputs.
    
    Args:
        param_def: Parameter definition dictionary containing:
            - PARAM_PROMPT: Prompt text to display
            - PARAM_TYPE: Type of input (text/number/toggle)
            - PARAM_DEFAULT: Optional default value
            - PARAM_ALLOWED_VALUES: Optional list for multiple choice
    
    Returns:
        User input value converted to appropriate type.
        
    Raises:
        EOFError: If stdin reaches EOF (non-interactive environment).
        ValueError: If input cannot be converted to required type.
    """
    # Block 2.8.1.1: Get allowed values for multiple choice
    allowed_values = param_def.get(PARAM_ALLOWED_VALUES)
    if allowed_values:
        _display_multiple_choice_options(allowed_values)
    
    # Block 2.8.1.2: Format and display prompt text
    prompt_text = _format_prompt_text(param_def)
    user_input = input(prompt_text)
    
    # Block 2.8.1.3: Handle multiple choice if allowed values present
    if allowed_values:
        return _handle_multiple_choice_input(param_def, user_input, allowed_values)
    
    # Block 2.8.1.4: Get param type with text as default
    param_type = param_def.get(PARAM_TYPE, PARAM_TYPE_TEXT)
    
    # Block 2.8.1.5: Route to appropriate handler based on type
    if param_type == PARAM_TYPE_NUMBER:
        return _handle_number_input(param_def, user_input)
    elif param_type == PARAM_TYPE_TOGGLE:
        return _handle_toggle_input(param_def, user_input)
    else:
        return _handle_text_input(param_def, user_input)
```

**Test 2.8.2: Tests for EOF handling in non-interactive environment**

```gherkin
Scenario: EOF on stdin raises EOFError
  Given a param with PARAM_TYPE_TEXT
  And stdin is mocked with StringIO("") (empty)
  When prompt_for_value() is called
  Then EOFError is raised
  And no value is returned
  
  # Tests: EOF handling when stdin closes unexpectedly
  # Validates: Framework detects and reports EOF condition properly
```

```python
# Test 2.8.2: Add to tests/test_input_prompt.py
def test_prompt_eof_raises_error(monkeypatch):
    """Test that EOF condition raises EOFError when stdin closes unexpectedly.
    
    This test verifies that when stdin is empty (EOF condition from Ctrl+D, closed pipe,
    or automated scripts), the handler raises EOFError rather than failing silently.
    This behaviour is expected because EOF must be detected and reported clearly,
    ensuring the application fails predictably in non-interactive environments."""
    # Block 2.8.2.1: Import required modules
    from io import StringIO
    import pytest
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_TEXT, PARAM_PROMPT
    
    # Block 2.8.2.2: Create param definition
    param_def = {
        PARAM_PROMPT: 'Enter value',
        PARAM_TYPE: PARAM_TYPE_TEXT
    }
    
    # Block 2.8.2.3: Mock stdin with empty stream (EOF)
    mock_stdin = StringIO("")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.8.2.4: Verify EOFError raised
    with pytest.raises(EOFError):
        input_prompt.prompt_for_value(param_def)
```

[↑ Back to top](#table-of-contents)

---

**Step 2b: Test constants**

```gherkin
Scenario: Text input handler returns user-entered string
  Given a param with PARAM_TYPE_TEXT and no default value
  And stdin is mocked with StringIO("test value\n")
  When prompt_for_value() is called
  Then the function returns "test value"
  
  # Tests: Basic text input handling with input() function
  # Validates: String input is captured and returned correctly
```

```python
# Test 2.3.2: Add to tests/test_input_prompt.py
def test_prompt_text_input_returns_string(monkeypatch):
    """Test that the default prompt handler captures plain text input from users.
    
    This test verifies that when stdin is mocked with StringIO containing "test value",
    the prompt_for_value() function returns exactly that string without modification.
    This behaviour is expected because text parameters are the simplest type and should
    return user input verbatim, establishing the foundation for all other input types."""
    # Block 2.3.2.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_TEXT, PARAM_NAME
    
    # Block 2.3.2.2: Create param definition for text input
    param_def = {
        PARAM_NAME: 'test_param',
        PARAM_TYPE: PARAM_TYPE_TEXT
    }
    
    # Block 2.3.2.3: Mock stdin with test input
    mock_stdin = StringIO("test value\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.3.2.4: Call prompt handler
    user_value = input_prompt.prompt_for_value(param_def)
    
    # Block 2.3.2.5: Verify returned value
    assert user_value == "test value", "Expected 'test value', got '{0}'".format(user_value)
```

**Test 2.3.3: Tests for blank input with default value**

```gherkin
Scenario: Blank input with default value returns the default
  Given a param with PARAM_TYPE_TEXT and PARAM_DEFAULT "default_value"
  And stdin is mocked with StringIO("\n")
  When prompt_for_value() is called
  Then the function returns "default_value"
  
  # Tests: Default value handling for text input
  # Validates: Blank input selects default using bash convention
```

```python
# Test 2.3.3: Add to tests/test_input_prompt.py
def test_prompt_text_with_default_blank_input(monkeypatch):
    """Test that pressing Enter without typing selects the default value automatically.
    
    This test verifies that when stdin is mocked with just a newline character and
    PARAM_DEFAULT is set, the function returns the default value.
    This behaviour is expected because the bash convention of showing "[default: value]"
    implies that blank input (just pressing Enter) will use that default value."""
    # Block 2.3.3.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_TEXT, PARAM_DEFAULT
    
    # Block 2.3.3.2: Create param with default value
    param_def = {
        PARAM_TYPE: PARAM_TYPE_TEXT,
        PARAM_DEFAULT: 'default_value'
    }
    
    # Block 2.3.3.3: Mock stdin with blank input (just newline)
    mock_stdin = StringIO("\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.3.3.4: Call prompt handler
    user_value = input_prompt.prompt_for_value(param_def)
    
    # Block 2.3.3.5: Verify default value returned
    assert user_value == 'default_value', "Expected 'default_value', got '{0}'".format(user_value)
```

**Test 2.4.2: Tests for number integer input conversion**

```gherkin
Scenario: Valid integer input converted correctly
  Given a param with PARAM_TYPE_NUMBER
  And stdin is mocked with StringIO("42\n")
  When prompt_for_value() is called
  Then the function returns 42 as integer
  And no conversion errors occur
  
  # Tests: Number input with integer conversion
  # Validates: Integer strings converted to int type
```

```python
# Test 2.4.2: Add to tests/test_input_prompt.py
def test_prompt_number_integer_valid(monkeypatch):
    """Test that integer input is correctly converted to int type for numeric parameters.
    
    This test verifies that when a user enters "42" for a PARAM_TYPE_NUMBER parameter,
    the handler converts it to the integer 42 (not string or float).
    This behaviour is expected because integer input (no decimal point) should be
    converted using int() for proper numeric operations, counters, and array indices."""
    # Block 2.4.2.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_NUMBER, PARAM_PROMPT
    
    # Block 2.4.2.2: Create param definition for number input
    param_def = {
        PARAM_PROMPT: 'Enter number',
        PARAM_TYPE: PARAM_TYPE_NUMBER
    }
    
    # Block 2.4.2.3: Mock stdin with integer input
    mock_stdin = StringIO("42\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.4.2.4: Call prompt handler
    result_value = input_prompt.prompt_for_value(param_def)
    
    # Block 2.4.2.5: Verify integer type and value
    assert isinstance(result_value, int), "Expected int type, got {0}".format(type(result_value))
    assert result_value == 42, "Expected 42, got {0}".format(result_value)
```

**Test 2.4.3: Tests for number float input conversion**

```gherkin
Scenario: Valid float input converted correctly
  Given a param with PARAM_TYPE_NUMBER  
  And stdin is mocked with StringIO("3.14\n")
  When prompt_for_value() is called
  Then the function returns 3.14 as float
  And no conversion errors occur
  
  # Tests: Number input with float conversion
  # Validates: Float strings converted to float type
```

```python
# Test 2.4.3: Add to tests/test_input_prompt.py
def test_prompt_number_float_valid(monkeypatch):
    """Test that floating-point input is correctly converted to float type for numeric parameters.
    
    This test verifies that when a user enters "3.14" for a PARAM_TYPE_NUMBER parameter,
    the handler converts it to the float 3.14 (not string or integer).
    This behaviour is expected because float input (contains decimal point) should be
    converted using float() for precise measurements, percentages, and scientific values."""
    # Block 2.4.3.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_NUMBER, PARAM_PROMPT
    
    # Block 2.4.3.2: Create param definition for number input
    param_def = {
        PARAM_PROMPT: 'Enter number',
        PARAM_TYPE: PARAM_TYPE_NUMBER
    }
    
    # Block 2.4.3.3: Mock stdin with float input
    mock_stdin = StringIO("3.14\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.4.3.4: Call prompt handler
    result_value = input_prompt.prompt_for_value(param_def)
    
    # Block 2.4.3.5: Verify float type and value
    assert isinstance(result_value, float), "Expected float type, got {0}".format(type(result_value))
    assert result_value == 3.14, "Expected 3.14, got {0}".format(result_value)
```

**Test 2.4.4: Tests for number invalid input validation**

```gherkin
Scenario: Invalid number input raises ValueError
  Given a param with PARAM_TYPE_NUMBER
  And stdin is mocked with StringIO("not_a_number\n")
  When prompt_for_value() is called
  Then ValueError is raised
  And error message indicates conversion failure
  
  # Tests: Number input validation
  # Validates: Non-numeric input rejected with clear error
```

```python
# Test 2.4.4: Add to tests/test_input_prompt.py
def test_prompt_number_invalid_raises_error(monkeypatch):
    """Test that non-numeric input raises ValueError for numeric parameters.
    
    This test verifies that when a user enters "not_a_number" for a PARAM_TYPE_NUMBER parameter,
    the handler raises ValueError rather than returning invalid data.
    This behaviour is expected because type conversion failures must be caught and reported
    clearly, enabling retry logic at higher levels to prompt the user again."""
    # Block 2.4.4.1: Import required modules
    from io import StringIO
    import pytest
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_NUMBER, PARAM_PROMPT
    
    # Block 2.4.4.2: Create param definition for number input
    param_def = {
        PARAM_PROMPT: 'Enter number',
        PARAM_TYPE: PARAM_TYPE_NUMBER
    }
    
    # Block 2.4.4.3: Mock stdin with invalid input
    mock_stdin = StringIO("not_a_number\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.4.4.4: Verify ValueError raised
    with pytest.raises(ValueError):
        input_prompt.prompt_for_value(param_def)
```

**Test 2.5.2: Tests for toggle affirmative input variations**

```gherkin
Scenario: Toggle input accepts multiple affirmative formats
  Given a param with PARAM_TYPE_TOGGLE
  And stdin provides "y", "Y", "yes", "YES", "true", "True" in sequence
  When prompt_for_value() is called for each input
  Then all return True boolean value
  And case-insensitive matching works correctly
  
  # Tests: Toggle input affirmative value recognition
  # Validates: Multiple formats accepted for true/yes values
```

```python
# Test 2.5.2: Add to tests/test_input_prompt.py
def test_prompt_toggle_yes_variations(monkeypatch):
    """Test that toggle parameters accept multiple affirmative formats with case-insensitive matching.
    
    This test verifies that inputs "y", "Y", "yes", "YES", "true", and "True" all return
    the Python boolean True for PARAM_TYPE_TOGGLE parameters.
    This behaviour is expected because providing flexible, user-friendly input options
    improves usability rather than forcing users to remember exact format requirements."""
    # Block 2.5.2.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_TOGGLE, PARAM_PROMPT
    
    # Block 2.5.2.2: Create param definition for toggle input
    param_def = {
        PARAM_PROMPT: 'Confirm?',
        PARAM_TYPE: PARAM_TYPE_TOGGLE
    }
    
    # Block 2.5.2.3: Test all affirmative variations
    affirmative_inputs = ['y', 'Y', 'yes', 'YES', 'true', 'True']
    for test_input in affirmative_inputs:
        mock_stdin = StringIO("{0}\n".format(test_input))
        monkeypatch.setattr('sys.stdin', mock_stdin)
        result_value = input_prompt.prompt_for_value(param_def)
        assert result_value is True, "Input '{0}' should return True".format(test_input)
```

**Test 2.5.3: Tests for toggle negative input variations**

```gherkin
Scenario: Toggle input accepts multiple negative formats
  Given a param with PARAM_TYPE_TOGGLE
  And stdin provides "n", "N", "no", "NO", "false", "False" in sequence  
  When prompt_for_value() is called for each input
  Then all return False boolean value
  And case-insensitive matching works correctly
  
  # Tests: Toggle input negative value recognition
  # Validates: Multiple formats accepted for false/no values
```

```python
# Test 2.5.3: Add to tests/test_input_prompt.py
def test_prompt_toggle_no_variations(monkeypatch):
    """Test that toggle parameters accept multiple negative formats with case-insensitive matching.
    
    This test verifies that inputs "n", "N", "no", "NO", "false", and "False" all return
    the Python boolean False for PARAM_TYPE_TOGGLE parameters.
    This behaviour is expected because comprehensive support for common negative variations
    provides a complete and intuitive toggle input experience."""
    # Block 2.5.3.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_TOGGLE, PARAM_PROMPT
    
    # Block 2.5.3.2: Create param definition for toggle input
    param_def = {
        PARAM_PROMPT: 'Confirm?',
        PARAM_TYPE: PARAM_TYPE_TOGGLE
    }
    
    # Block 2.5.3.3: Test all negative variations
    negative_inputs = ['n', 'N', 'no', 'NO', 'false', 'False']
    for test_input in negative_inputs:
        mock_stdin = StringIO("{0}\n".format(test_input))
        monkeypatch.setattr('sys.stdin', mock_stdin)
        result_value = input_prompt.prompt_for_value(param_def)
        assert result_value is False, "Input '{0}' should return False".format(test_input)
```

**Test 2.5.4: Tests for toggle invalid input validation**

```gherkin
Scenario: Invalid toggle input raises ValueError
  Given a param with PARAM_TYPE_TOGGLE
  And stdin is mocked with StringIO("maybe\n")
  When prompt_for_value() is called
  Then ValueError is raised
  And error message indicates expected formats
  
  # Tests: Toggle input validation
  # Validates: Unrecognized input rejected with helpful error
```

```python
# Test 2.5.4: Add to tests/test_input_prompt.py
def test_prompt_toggle_invalid_raises_error(monkeypatch):
    """Test that unrecognized input raises ValueError for toggle parameters.
    
    This test verifies that when a user enters "maybe" for a PARAM_TYPE_TOGGLE parameter,
    the handler raises ValueError with a clear message about expected formats.
    This behaviour is expected because ambiguous or invalid input must be rejected,
    enabling retry logic to prompt the user again with guidance on valid options."""
    # Block 2.5.4.1: Import required modules
    from io import StringIO
    import pytest
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_TOGGLE, PARAM_PROMPT
    
    # Block 2.5.4.2: Create param definition for toggle input
    param_def = {
        PARAM_PROMPT: 'Confirm?',
        PARAM_TYPE: PARAM_TYPE_TOGGLE
    }
    
    # Block 2.5.4.3: Mock stdin with invalid input
    mock_stdin = StringIO("maybe\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.5.4.4: Verify ValueError raised with helpful message
    with pytest.raises(ValueError, match="Expected y/yes/true or n/no/false"):
        input_prompt.prompt_for_value(param_def)
```

**Test 2.6.2: Tests for multiple choice selection by number**

```gherkin
Scenario: Multiple choice selection by number works correctly
  Given a param with PARAM_ALLOWED_VALUES ["option1", "option2", "option3"]
  And stdin is mocked with StringIO("2\n")
  When prompt_for_value() is called
  Then numbered list displayed: "1. option1\n2. option2\n3. option3"
  And the function returns "option2"
  
  # Tests: Multiple choice selection by index number
  # Validates: Users can select by entering list number
```

```python
# Test 2.6.2: Add to tests/test_input_prompt.py
def test_prompt_multiple_choice_by_number(monkeypatch, capsys):
    """Test that users can select from multiple choice options by entering the numeric index.
    
    This test verifies that when PARAM_ALLOWED_VALUES contains ["red", "green", "blue"]
    and the user enters "2", the handler returns "green" (the second option).
    This behaviour is expected because numbered selection provides an efficient interface
    where users can type a single digit instead of the full option text."""
    # Block 2.6.2.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_PROMPT, PARAM_ALLOWED_VALUES
    
    # Block 2.6.2.2: Create param with allowed values
    param_def = {
        PARAM_PROMPT: 'Select option',
        PARAM_ALLOWED_VALUES: ['red', 'green', 'blue']
    }
    
    # Block 2.6.2.3: Mock stdin with numeric selection
    mock_stdin = StringIO("2\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.6.2.4: Call prompt handler
    selected_value = input_prompt.prompt_for_value(param_def)
    
    # Block 2.6.2.5: Verify correct option selected
    assert selected_value == 'green', "Expected 'green', got '{0}'".format(selected_value)
    
    # Block 2.6.2.6: Verify numbered list was displayed
    captured_output = capsys.readouterr()
    assert '1. red' in captured_output.out, "Option 1 not displayed"
    assert '2. green' in captured_output.out, "Option 2 not displayed"
    assert '3. blue' in captured_output.out, "Option 3 not displayed"
```

**Test 2.6.3: Tests for multiple choice selection by exact text**

```gherkin
Scenario: Multiple choice selection by exact text works correctly
  Given a param with PARAM_ALLOWED_VALUES ["red", "green", "blue"]
  And stdin is mocked with StringIO("green\n")
  When prompt_for_value() is called
  Then the function returns "green"
  And selection matches exact text from allowed values
  
  # Tests: Multiple choice selection by typing exact value
  # Validates: Users can select by entering the text value directly
```

```python
# Test 2.6.3: Add to tests/test_input_prompt.py
def test_prompt_multiple_choice_by_text(monkeypatch):
    """Test that users can select from multiple choice options by entering the exact text value.
    
    This test verifies that when PARAM_ALLOWED_VALUES contains ["red", "green", "blue"]
    and the user enters "green", the handler returns "green" directly.
    This behaviour is expected because some users prefer typing the full option name
    rather than remembering numeric indices, providing flexible selection methods."""
    # Block 2.6.3.1: Import required modules
    from io import StringIO
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_PROMPT, PARAM_ALLOWED_VALUES
    
    # Block 2.6.3.2: Create param with allowed values
    param_def = {
        PARAM_PROMPT: 'Select colour',
        PARAM_ALLOWED_VALUES: ['red', 'green', 'blue']
    }
    
    # Block 2.6.3.3: Mock stdin with text selection
    mock_stdin = StringIO("green\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.6.3.4: Call prompt handler
    selected_value = input_prompt.prompt_for_value(param_def)
    
    # Block 2.6.3.5: Verify correct text match
    assert selected_value == 'green', "Expected 'green', got '{0}'".format(selected_value)
```

**Test 2.6.4: Tests for multiple choice invalid selection validation**

```gherkin
Scenario: Invalid multiple choice selection raises ValueError
  Given a param with PARAM_ALLOWED_VALUES ["red", "green", "blue"]
  And stdin is mocked with StringIO("yellow\n")
  When prompt_for_value() is called
  Then ValueError is raised
  And error message indicates invalid selection
  
  # Tests: Multiple choice validation
  # Validates: Invalid selections rejected with clear error
```

```python
# Test 2.6.4: Add to tests/test_input_prompt.py
def test_prompt_multiple_choice_invalid_selection(monkeypatch):
    """Test that invalid selections raise ValueError for multiple choice parameters.
    
    This test verifies that when the user enters "yellow" for options ["red", "green", "blue"],
    the handler raises ValueError with a message about valid selection methods.
    This behaviour is expected because only values in PARAM_ALLOWED_VALUES or their indices
    are valid, and invalid selections must be rejected to enable retry logic."""
    # Block 2.6.4.1: Import required modules
    from io import StringIO
    import pytest
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_PROMPT, PARAM_ALLOWED_VALUES
    
    # Block 2.6.4.2: Create param with allowed values
    param_def = {
        PARAM_PROMPT: 'Select colour',
        PARAM_ALLOWED_VALUES: ['red', 'green', 'blue']
    }
    
    # Block 2.6.4.3: Mock stdin with invalid selection
    mock_stdin = StringIO("yellow\n")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.6.4.4: Verify ValueError raised
    with pytest.raises(ValueError, match="Invalid selection"):
        input_prompt.prompt_for_value(param_def)
```

**Test 2.7.2: Tests for EOF handling in non-interactive environment**

```gherkin
Scenario: EOF on stdin raises EOFError
  Given a param with PARAM_TYPE_TEXT
  And stdin is mocked with StringIO("") (empty)
  When prompt_for_value() is called
  Then EOFError is raised
  And no value is returned
  
  # Tests: EOF handling when stdin closes unexpectedly
  # Validates: Framework detects and reports EOF condition properly
```

```python
# Test 2.7.2: Add to tests/test_input_prompt.py
def test_prompt_eof_raises_error(monkeypatch):
    """Test that EOF condition raises EOFError when stdin closes unexpectedly.
    
    This test verifies that when stdin is empty (EOF condition from Ctrl+D, closed pipe,
    or automated scripts), the handler raises EOFError rather than failing silently.
    This behaviour is expected because EOF must be detected and reported clearly,
    ensuring the application fails predictably in non-interactive environments."""
    # Block 2.7.2.1: Import required modules
    from io import StringIO
    import pytest
    from spafw37 import input_prompt
    from spafw37.constants.param import PARAM_TYPE, PARAM_TYPE_TEXT, PARAM_PROMPT
    
    # Block 2.7.2.2: Create param definition
    param_def = {
        PARAM_PROMPT: 'Enter value',
        PARAM_TYPE: PARAM_TYPE_TEXT
    }
    
    # Block 2.7.2.3: Mock stdin with empty stream (EOF)
    mock_stdin = StringIO("")
    monkeypatch.setattr('sys.stdin', mock_stdin)
    
    # Block 2.7.2.4: Verify EOFError raised
    with pytest.raises(EOFError):
        input_prompt.prompt_for_value(param_def)
```

[↑ Back to top](#table-of-contents)

---

**Step 3: Add param registration logic**

**File:** `src/spafw37/param.py`

Add internal state for prompt handling, extend parameter registration to validate and store prompt properties, and provide public APIs for dynamic configuration.

**Implementation order:**

1. Add module-level storage for global prompt handler and prompted params tracking
2. Import new prompt constants from constants/param.py module
3. Create validation helper to check prompt timing values are valid
4. Create validation helper to check prompt repeat values are valid
5. Add prompt property validation to parameter registration flow
6. Implement public API function to set global prompt handler
7. Implement public API function to update allowed values dynamically
8. Add unit tests for validation helpers
9. Add unit tests for prompt property storage during registration
10. Add unit tests for public API functions

**Code 3.1.1: Module-level prompt state**

```python
# Block 3.1.1: Add after _SWITCH_REGISTER constant in src/spafw37/param.py
# Global prompt handler storage (None = use default handler)
_global_prompt_handler = None

# Tracked params that have been prompted (for PROMPT_REPEAT_NEVER)
_prompted_params = set()

# Auto-population flag marker (internal use only)
_PROMPT_AUTO_POPULATE = '_prompt_auto_populate'
```

**Test 3.1.2: Tests for module-level state initialisation**

```gherkin
Scenario: Module-level prompt state initialises correctly
  Given the param module is imported
  When checking module-level variables
  Then _global_prompt_handler is None
  And _prompted_params is an empty set
  And _PROMPT_AUTO_POPULATE constant is defined
  
  # Tests: Module-level state initialisation
  # Validates: Prompt state starts in clean initial state
```

```python
# Test 3.1.2: Add to tests/test_param_prompts.py
def test_module_level_prompt_state_initialised():
    """Test that module-level prompt state variables are initialised correctly.
    
    This test verifies _global_prompt_handler starts as None (no custom handler),
    _prompted_params starts as empty set (no prompts executed yet), and the
    _PROMPT_AUTO_POPULATE flag constant is defined for marking params during registration.
    This behaviour is expected because clean initial state ensures no leftover configuration
    from previous test runs or imports affects prompt behaviour."""
    # Block 3.1.2.1: Import param module
    from spafw37 import param
    
    # Block 3.1.2.2: Verify global handler starts as None
    assert param._global_prompt_handler is None, "Global handler should start as None"
    
    # Block 3.1.2.3: Verify prompted params tracking starts empty
    assert isinstance(param._prompted_params, set), "Prompted params must be a set"
    assert len(param._prompted_params) == 0, "Prompted params should start empty"
    
    # Block 3.1.2.4: Verify auto-populate flag constant exists
    assert hasattr(param, '_PROMPT_AUTO_POPULATE'), "Auto-populate flag constant missing"
    assert isinstance(param._PROMPT_AUTO_POPULATE, str), "Flag must be string key"
```

**Code 3.2.1: Import prompt constants**

```python
# Block 3.2.1: Add to imports section after existing PARAM_* imports
from spafw37.constants.param import (
    # ... existing imports ...
    PARAM_PROMPT,
    PARAM_PROMPT_HANDLER,
    PARAM_PROMPT_TIMING,
    PARAM_PROMPT_REPEAT,
    PROMPT_ON_START,
    PROMPT_ON_COMMAND,
    PROMPT_REPEAT_ALWAYS,
    PROMPT_REPEAT_IF_BLANK,
    PROMPT_REPEAT_NEVER,
)
```

**Code 3.3.1: Validate prompt timing value**

```python
# Block 3.3.1: Add before add_param() function
def _validate_prompt_timing(timing_value):
    """Validate PARAM_PROMPT_TIMING value is a recognised constant.
    
    Args:
        timing_value: Value from PARAM_PROMPT_TIMING property.
        
    Raises:
        ValueError: If timing value is not valid.
    """
    # Block 3.3.1.1: Accept PROMPT_ON_START constant
    if timing_value == PROMPT_ON_START:
        return
    
    # Block 3.3.1.2: Accept PROMPT_ON_COMMAND constant
    if timing_value == PROMPT_ON_COMMAND:
        return
    
    # Block 3.3.1.3: Reject all other values
    raise ValueError(
        "PARAM_PROMPT_TIMING must be PROMPT_ON_START or PROMPT_ON_COMMAND constant"
    )
```

**Test 3.3.2: Tests for prompt timing validation with valid constant**

```gherkin
Scenario: PROMPT_ON_START constant passes validation
  Given timing value set to PROMPT_ON_START constant
  When _validate_prompt_timing() is called
  Then no exception is raised
  And validation passes successfully
  
  # Tests: Valid timing constant acceptance
  # Validates: PROMPT_ON_START recognised as valid timing value
```

```python
# Test 3.3.2: Add to tests/test_param_prompts.py
def test_validate_prompt_timing_with_on_start():
    """Test that PROMPT_ON_START constant passes timing validation successfully.
    
    This test verifies _validate_prompt_timing() accepts the PROMPT_ON_START constant
    without raising exceptions, as this is one of the two valid timing modes.
    This behaviour is expected because PROMPT_ON_START indicates prompts should run
    immediately after CLI parsing, before command execution, which is a core timing option."""
    # Block 3.3.2.1: Import required modules
    from spafw37 import param
    from spafw37.constants.param import PROMPT_ON_START
    
    # Block 3.3.2.2: Call validation with PROMPT_ON_START
    try:
        param._validate_prompt_timing(PROMPT_ON_START)
        validation_passed = True
    except ValueError:
        validation_passed = False
    
    # Block 3.3.2.3: Verify validation passed
    assert validation_passed, "PROMPT_ON_START should pass validation"
```

**Test 3.3.3: Tests for prompt timing validation with PROMPT_ON_COMMAND constant**

```gherkin
Scenario: PROMPT_ON_COMMAND constant passes validation
  Given timing value set to PROMPT_ON_COMMAND constant
  When _validate_prompt_timing() is called
  Then no exception is raised
  And validation passes successfully
  
  # Tests: Valid timing constant acceptance
  # Validates: PROMPT_ON_COMMAND recognised as valid timing value
```

```python
# Test 3.3.3: Add to tests/test_param_prompts.py
def test_validate_prompt_timing_with_on_command():
    """Test that PROMPT_ON_COMMAND constant passes timing validation successfully.
    
    This test verifies _validate_prompt_timing() accepts the PROMPT_ON_COMMAND constant
    without raising exceptions, as this indicates prompts should run before specific commands.
    This behaviour is expected because PROMPT_ON_COMMAND tells the framework to check the
    PROMPT_ON_COMMANDS property for the list of commands to prompt before."""
    # Block 3.3.3.1: Import required modules
    from spafw37 import param
    from spafw37.constants.param import PROMPT_ON_COMMAND
    
    # Block 3.3.3.2: Call validation with PROMPT_ON_COMMAND
    try:
        param._validate_prompt_timing(PROMPT_ON_COMMAND)
        validation_passed = True
    except ValueError:
        validation_passed = False
    
    # Block 3.3.3.3: Verify validation passed
    assert validation_passed, "PROMPT_ON_COMMAND should pass validation"
```

**Test 3.3.4: Tests for prompt timing validation rejection of invalid values**

```gherkin
Scenario: Invalid timing value raises ValueError
  Given timing value set to "invalid_constant" or a list
  When _validate_prompt_timing() is called
  Then ValueError is raised
  And error message indicates valid options (PROMPT_ON_START or PROMPT_ON_COMMAND)
  
  # Tests: Invalid timing value rejection
  # Validates: Only PROMPT_ON_START or PROMPT_ON_COMMAND constants accepted
```

```python
# Test 3.3.4: Add to tests/test_param_prompts.py
def test_validate_prompt_timing_rejects_invalid_value():
    """Test that invalid timing values raise ValueError during validation.
    
    This test verifies _validate_prompt_timing() rejects values that are neither
    PROMPT_ON_START constant nor lists, such as arbitrary strings like "invalid".
    This behaviour is expected because accepting invalid timing values would cause
    subtle runtime errors when the framework tries to determine when to prompt."""
    # Block 3.3.4.1: Import required modules
    from spafw37 import param
    import pytest
    
    # Block 3.3.4.2: Attempt validation with invalid value
    with pytest.raises(ValueError, match="PARAM_PROMPT_TIMING must be"):
        param._validate_prompt_timing("invalid_constant")
```

**Code 3.4.1: Validate prompt repeat value**

```python
# Block 3.4.1: Add after _validate_prompt_timing() function
def _validate_prompt_repeat(repeat_value):
    """Validate PARAM_PROMPT_REPEAT value is a recognised constant.
    
    Args:
        repeat_value: Value from PARAM_PROMPT_REPEAT property.
        
    Raises:
        ValueError: If repeat value is not valid.
    """
    # Block 3.4.1.1: Check against all valid repeat constants
    valid_repeats = (PROMPT_REPEAT_ALWAYS, PROMPT_REPEAT_IF_BLANK, PROMPT_REPEAT_NEVER)
    if repeat_value not in valid_repeats:
        raise ValueError(
            "PARAM_PROMPT_REPEAT must be one of: PROMPT_REPEAT_ALWAYS, "
            "PROMPT_REPEAT_IF_BLANK, PROMPT_REPEAT_NEVER"
        )
```

**Test 3.4.2: Tests for prompt repeat validation with valid constants**

```gherkin
Scenario: All three PROMPT_REPEAT_* constants pass validation
  Given repeat values PROMPT_REPEAT_ALWAYS, PROMPT_REPEAT_IF_BLANK, PROMPT_REPEAT_NEVER
  When _validate_prompt_repeat() is called for each
  Then no exceptions are raised
  And all three constants accepted
  
  # Tests: Valid repeat constant acceptance
  # Validates: All repeat behaviour options recognised
```

```python
# Test 3.4.2: Add to tests/test_param_prompts.py
def test_validate_prompt_repeat_with_valid_constants():
    """Test that all PROMPT_REPEAT_* constants pass repeat validation successfully.
    
    This test verifies _validate_prompt_repeat() accepts PROMPT_REPEAT_ALWAYS,
    PROMPT_REPEAT_IF_BLANK, and PROMPT_REPEAT_NEVER without raising exceptions.
    This behaviour is expected because these three constants represent the complete
    set of valid repeat behaviours for prompts in cycle and multi-command scenarios."""
    # Block 3.4.2.1: Import required modules
    from spafw37 import param
    from spafw37.constants.param import (
        PROMPT_REPEAT_ALWAYS,
        PROMPT_REPEAT_IF_BLANK,
        PROMPT_REPEAT_NEVER
    )
    
    # Block 3.4.2.2: Test each valid constant
    valid_constants = [PROMPT_REPEAT_ALWAYS, PROMPT_REPEAT_IF_BLANK, PROMPT_REPEAT_NEVER]
    for repeat_constant in valid_constants:
        try:
            param._validate_prompt_repeat(repeat_constant)
            validation_passed = True
        except ValueError:
            validation_passed = False
        
        assert validation_passed, "Constant {0} should pass validation".format(repeat_constant)
```

**Test 3.4.3: Tests for prompt repeat validation rejection of invalid values**

```gherkin
Scenario: Invalid repeat value raises ValueError
  Given repeat value set to "invalid_repeat"
  When _validate_prompt_repeat() is called
  Then ValueError is raised
  And error message lists valid constants
  
  # Tests: Invalid repeat value rejection
  # Validates: Only valid PROMPT_REPEAT_* constants accepted
```

```python
# Test 3.4.3: Add to tests/test_param_prompts.py
def test_validate_prompt_repeat_rejects_invalid_value():
    """Test that invalid repeat values raise ValueError during validation.
    
    This test verifies _validate_prompt_repeat() rejects arbitrary values that are
    not one of the three valid PROMPT_REPEAT_* constants.
    This behaviour is expected because accepting invalid repeat values would cause
    undefined behaviour in cycle logic where the framework checks repeat mode."""
    # Block 3.4.3.1: Import required modules
    from spafw37 import param
    import pytest
    
    # Block 3.4.3.2: Attempt validation with invalid value
    with pytest.raises(ValueError, match="PARAM_PROMPT_REPEAT must be one of"):
        param._validate_prompt_repeat("invalid_repeat")
```

**Code 3.5.1: Validate and process prompt properties in add_param**

```python
# Block 3.5.1: Add after _apply_runtime_only_constraint() call in add_param()
def _validate_and_process_prompt_properties(_param):
    """Validate and process prompt-related properties during parameter registration.
    
    Args:
        _param: Parameter definition dictionary.
        
    Raises:
        ValueError: If prompt properties are invalid or required fields missing.
    """
    # Block 3.5.1.1: Skip if param has no PARAM_PROMPT (not a prompt-enabled param)
    if PARAM_PROMPT not in _param:
        return
    
    # Block 3.5.1.2: Validate PARAM_PROMPT is a non-empty string
    prompt_text = _param[PARAM_PROMPT]
    if not isinstance(prompt_text, str) or not prompt_text.strip():
        param_name = _param.get(PARAM_NAME, '<unknown>')
        raise ValueError(
            "PARAM_PROMPT must be a non-empty string for param '{0}'".format(param_name)
        )
    
    # Block 3.5.1.3: Validate PARAM_TYPE exists (required for input handling)
    if PARAM_TYPE not in _param:
        param_name = _param.get(PARAM_NAME, '<unknown>')
        raise ValueError(
            "PARAM_TYPE is required for prompt-enabled param '{0}'".format(param_name)
        )
    
    # Block 3.5.1.4: Validate timing if specified
    if PARAM_PROMPT_TIMING in _param:
        _validate_prompt_timing(_param[PARAM_PROMPT_TIMING])
    else:
        # Block 3.5.1.5: Mark for auto-population if no explicit timing
        _param[_PROMPT_AUTO_POPULATE] = True
    
    # Block 3.5.1.6: Validate repeat behaviour if specified
    if PARAM_PROMPT_REPEAT in _param:
        _validate_prompt_repeat(_param[PARAM_PROMPT_REPEAT])
```

**Test 3.5.2: Tests for prompt property validation during registration**

```gherkin
Scenario: Param with PARAM_PROMPT and valid timing registers successfully
  Given a param with PARAM_PROMPT and PARAM_PROMPT_TIMING set to PROMPT_ON_START
  When add_param() is called
  Then param is registered without errors
  And PARAM_PROMPT_TIMING property is preserved
  
  # Tests: Successful registration with valid prompt properties
  # Validates: Validation accepts valid prompt configurations
```

```python
# Test 3.5.2: Add to tests/test_param_prompts.py
def test_param_with_valid_prompt_properties_registers():
    """Test that params with valid prompt properties register successfully without errors.
    
    This test verifies add_param() accepts parameters with PARAM_PROMPT and valid
    PARAM_PROMPT_TIMING (PROMPT_ON_START), storing all properties correctly.
    This behaviour is expected because properly configured prompt params are valid
    and should integrate seamlessly with the registration system."""
    # Block 3.5.2.1: Import required modules
    from spafw37 import param
    from spafw37.constants.param import (
        PARAM_NAME,
        PARAM_PROMPT,
        PARAM_PROMPT_TIMING,
        PROMPT_ON_START
    )
    
    # Block 3.5.2.2: Clear any existing params
    param._params = {}
    
    # Block 3.5.2.3: Create param with valid prompt properties
    test_param = {
        PARAM_NAME: 'test_prompt_param',
        PARAM_PROMPT: 'Enter value:',
        PARAM_PROMPT_TIMING: PROMPT_ON_START
    }
    
    # Block 3.5.2.4: Register param (should not raise)
    param.add_param(test_param)
    
    # Block 3.5.2.5: Verify param was registered with properties intact
    registered_param = param.get_param_by_name('test_prompt_param')
    assert registered_param is not None, "Param should be registered"
    assert registered_param[PARAM_PROMPT] == 'Enter value:', "PARAM_PROMPT not preserved"
    assert registered_param[PARAM_PROMPT_TIMING] == PROMPT_ON_START, "Timing not preserved"
```

**Test 3.5.3: Tests for auto-population flag on params without explicit timing**

```gherkin
Scenario: Param with PARAM_PROMPT but no timing gets auto-populate flag
  Given a param with PARAM_PROMPT but no PARAM_PROMPT_TIMING
  When add_param() is called
  Then param is registered with auto-populate flag set
  And flag indicates PROMPT_ON_COMMANDS should be populated from commands
  
  # Tests: Auto-population flag mechanism
  # Validates: Params without explicit timing marked for command-driven population
```

```python
# Test 3.5.3: Add to tests/test_param_prompts.py
def test_param_without_timing_gets_auto_populate_flag():
    """Test that params with PARAM_PROMPT but no explicit timing get auto-populate flag.
    
    This test verifies add_param() marks parameters with _PROMPT_AUTO_POPULATE flag
    when they have PARAM_PROMPT but don't specify PARAM_PROMPT_TIMING.
    This behaviour is expected because the auto-population mechanism allows commands
    to automatically trigger prompts for their required params without duplicate configuration."""
    # Block 3.5.3.1: Import required modules
    from spafw37 import param
    from spafw37.constants.param import PARAM_NAME, PARAM_PROMPT
    
    # Block 3.5.3.2: Clear any existing params
    param._params = {}
    
    # Block 3.5.3.3: Create param with PARAM_PROMPT but no timing
    test_param = {
        PARAM_NAME: 'auto_populate_param',
        PARAM_PROMPT: 'Enter value:'
    }
    
    # Block 3.5.3.4: Register param
    param.add_param(test_param)
    
    # Block 3.5.3.5: Verify auto-populate flag is set
    registered_param = param.get_param_by_name('auto_populate_param')
    assert registered_param[param._PROMPT_AUTO_POPULATE] is True, "Auto-populate flag should be set"
```

**Test 3.5.4: Tests for invalid prompt timing rejection during registration**

```gherkin
Scenario: Param with invalid PARAM_PROMPT_TIMING raises ValueError
  Given a param with PARAM_PROMPT_TIMING set to "invalid_value"
  When add_param() is called
  Then ValueError is raised
  And param is not registered
  
  # Tests: Invalid timing rejection at registration time
  # Validates: Registration fails fast for invalid configurations
```

```python
# Test 3.5.4: Add to tests/test_param_prompts.py
def test_param_with_invalid_timing_raises_error_on_registration():
    """Test that params with invalid PARAM_PROMPT_TIMING values are rejected during registration.
    
    This test verifies add_param() raises ValueError when a parameter specifies an
    invalid PARAM_PROMPT_TIMING value (not PROMPT_ON_START or a list).
    This behaviour is expected because failing fast during registration prevents subtle
    runtime errors when the framework tries to determine prompt timing."""
    # Block 3.5.4.1: Import required modules
    from spafw37 import param
    from spafw37.constants.param import PARAM_NAME, PARAM_PROMPT, PARAM_PROMPT_TIMING
    import pytest
    
    # Block 3.5.4.2: Clear any existing params
    param._params = {}
    
    # Block 3.5.4.3: Create param with invalid timing
    invalid_param = {
        PARAM_NAME: 'invalid_timing_param',
        PARAM_PROMPT: 'Enter value:',
        PARAM_PROMPT_TIMING: 'invalid_value'
    }
    
    # Block 3.5.4.4: Verify ValueError raised during registration
    with pytest.raises(ValueError, match="PARAM_PROMPT_TIMING must be"):
        param.add_param(invalid_param)
```

**Test 3.5.5: Tests for empty PARAM_PROMPT rejection during registration**

```gherkin
Scenario: Param with empty or whitespace-only PARAM_PROMPT raises ValueError
  Given a param with PARAM_PROMPT set to empty string or "   "
  When add_param() is called
  Then ValueError is raised
  And error message indicates PARAM_PROMPT must be non-empty string
  
  # Tests: PARAM_PROMPT field validation
  # Validates: Prompt text must be meaningful (non-empty string)
```

```python
# Test 3.5.5: Add to tests/test_param_prompts.py
def test_param_with_empty_prompt_raises_error():
    """Test that params with empty or whitespace-only PARAM_PROMPT are rejected.
    
    This test verifies add_param() raises ValueError when PARAM_PROMPT is an empty
    string or contains only whitespace, as prompt text must be meaningful.
    This behaviour is expected because empty prompts would confuse users and
    indicate a configuration error."""
    # Block 3.5.5.1: Import required modules
    from spafw37 import param
    from spafw37.constants.param import PARAM_NAME, PARAM_PROMPT, PARAM_TYPE, PARAM_TYPE_TEXT
    import pytest
    
    # Block 3.5.5.2: Clear any existing params
    param._params = {}
    
    # Block 3.5.5.3: Test empty string
    empty_param = {
        PARAM_NAME: 'empty_prompt',
        PARAM_TYPE: PARAM_TYPE_TEXT,
        PARAM_PROMPT: ''
    }
    with pytest.raises(ValueError, match="PARAM_PROMPT must be a non-empty string"):
        param.add_param(empty_param)
    
    # Block 3.5.5.4: Test whitespace-only string
    param._params = {}
    whitespace_param = {
        PARAM_NAME: 'whitespace_prompt',
        PARAM_TYPE: PARAM_TYPE_TEXT,
        PARAM_PROMPT: '   '
    }
    with pytest.raises(ValueError, match="PARAM_PROMPT must be a non-empty string"):
        param.add_param(whitespace_param)
```

**Test 3.5.6: Tests for missing PARAM_TYPE rejection for prompt params**

```gherkin
Scenario: Prompt param without PARAM_TYPE raises ValueError
  Given a param with PARAM_PROMPT but no PARAM_TYPE
  When add_param() is called
  Then ValueError is raised
  And error message indicates PARAM_TYPE required for prompt params
  
  # Tests: Required field validation for prompt params
  # Validates: PARAM_TYPE needed to determine input handling
```

```python
# Test 3.5.6: Add to tests/test_param_prompts.py
def test_prompt_param_without_type_raises_error():
    """Test that prompt-enabled params without PARAM_TYPE are rejected during registration.
    
    This test verifies add_param() raises ValueError when a parameter has PARAM_PROMPT
    but doesn't specify PARAM_TYPE, which is needed to determine input handling.
    This behaviour is expected because the framework needs PARAM_TYPE to know how to
    parse and validate user input (text, number, toggle, etc.)."""
    # Block 3.5.6.1: Import required modules
    from spafw37 import param
    from spafw37.constants.param import PARAM_NAME, PARAM_PROMPT
    import pytest
    
    # Block 3.5.6.2: Clear any existing params
    param._params = {}
    
    # Block 3.5.6.3: Create prompt param without PARAM_TYPE
    no_type_param = {
        PARAM_NAME: 'no_type_prompt',
        PARAM_PROMPT: 'Enter value:'
    }
    
    # Block 3.5.6.4: Verify ValueError raised during registration
    with pytest.raises(ValueError, match="PARAM_TYPE is required for prompt-enabled param"):
        param.add_param(no_type_param)
```

**Code 3.6.1: Public API to set global prompt handler**

```python
# Block 3.6.1: Add after add_pre_parse_args() function
def set_prompt_handler(handler):
    """Set the global prompt handler function for all parameters.
    
    This handler will be used for any parameter prompts that don't have
    a param-specific PARAM_PROMPT_HANDLER defined. Set to None to restore
    the default handler (input_prompt.prompt_for_value).
    
    Args:
        handler: Callable that accepts param_def dict and returns user input value.
                 Signature: handler(param_def) -> value
    """
    global _global_prompt_handler
    _global_prompt_handler = handler
```

**Test 3.6.2: Tests for set_prompt_handler storing custom handler**

```gherkin
Scenario: Custom prompt handler set via set_prompt_handler()
  Given a custom handler function custom_handler()
  When set_prompt_handler(custom_handler) is called
  Then _global_prompt_handler stores custom_handler reference
  And subsequent prompts will use custom_handler by default
  
  # Tests: Global handler registration
  # Validates: Custom handlers can replace default input() behaviour globally
```

```python
# Test 3.6.2: Add to tests/test_param_prompts.py
def test_set_prompt_handler_stores_custom_handler():
    """Test that set_prompt_handler() correctly stores custom handler reference globally.
    
    This test verifies set_prompt_handler() updates the module-level _global_prompt_handler
    variable with the provided custom handler function reference.
    This behaviour is expected because the global handler provides extensibility,
    allowing applications to replace the default input() handler with GUI prompts,
    API-based input, or other custom input mechanisms."""
    # Block 3.6.2.1: Import required modules
    from spafw37 import param
    
    # Block 3.6.2.2: Define a custom handler function
    def custom_handler(param_def):
        return "custom_value"
    
    # Block 3.6.2.3: Set the global handler
    param.set_prompt_handler(custom_handler)
    
    # Block 3.6.2.4: Verify handler was stored
    assert param._global_prompt_handler is custom_handler, "Custom handler should be stored"
    
    # Block 3.6.2.5: Clean up (restore None)
    param.set_prompt_handler(None)
```

**Test 3.6.3: Tests for set_prompt_handler restoring default with None**

```gherkin
Scenario: Passing None to set_prompt_handler restores default behaviour
  Given _global_prompt_handler was set to a custom handler
  When set_prompt_handler(None) is called
  Then _global_prompt_handler is set to None
  And default handler will be used for prompts
  
  # Tests: Handler restoration to default
  # Validates: Applications can revert to default behaviour
```

```python
# Test 3.6.3: Add to tests/test_param_prompts.py
def test_set_prompt_handler_with_none_restores_default():
    """Test that passing None to set_prompt_handler() restores default handler behaviour.
    
    This test verifies set_prompt_handler(None) clears the custom handler, setting
    _global_prompt_handler back to None (which signals use of default handler).
    This behaviour is expected because applications need a way to revert to default
    behaviour after setting a custom handler, ensuring flexibility in testing and configuration."""
    # Block 3.6.3.1: Import required modules
    from spafw37 import param
    
    # Block 3.6.3.2: Set a custom handler first
    def custom_handler(param_def):
        return "custom"
    param.set_prompt_handler(custom_handler)
    
    # Block 3.6.3.3: Restore default by passing None
    param.set_prompt_handler(None)
    
    # Block 3.6.3.4: Verify handler is None
    assert param._global_prompt_handler is None, "Handler should be None (default)"
```

**Code 3.7.1: Public API to set allowed values dynamically**

```python
# Block 3.7.1: Add after set_prompt_handler() function
def set_allowed_values(param_name, values):
    """Set or update PARAM_ALLOWED_VALUES for a parameter at runtime.
    
    This enables commands to populate multiple choice lists dynamically
    without requiring parameter re-registration.
    
    Args:
        param_name: Name of the parameter to update.
        values: List of allowed values for multiple choice prompts.
        
    Raises:
        ValueError: If parameter does not exist.
    """
    # Block 3.7.1.1: Get param definition (raises if not found)
    param_def = get_param_by_name(param_name)
    if param_def is None:
        raise ValueError("Parameter '{0}' not found".format(param_name))
    
    # Block 3.7.1.2: Update allowed values on param definition
    param_def[PARAM_ALLOWED_VALUES] = values
```

**Test 3.7.2: Tests for set_allowed_values updating existing param**

```gherkin
Scenario: Dynamic allowed values updated via set_allowed_values()
  Given a param "choices" already registered
  And param initially has no PARAM_ALLOWED_VALUES
  When set_allowed_values("choices", ["a", "b", "c"]) is called
  Then param definition updated with PARAM_ALLOWED_VALUES ["a", "b", "c"]
  And multiple choice prompting enabled for this param
  
  # Tests: Dynamic allowed values API
  # Validates: Commands can populate choice lists at runtime
```

```python
# Test 3.7.2: Add to tests/test_param_prompts.py
def test_set_allowed_values_updates_param_definition():
    """Test that set_allowed_values() dynamically updates PARAM_ALLOWED_VALUES on existing param.
    
    This test verifies set_allowed_values() successfully adds or updates the PARAM_ALLOWED_VALUES
    property on a registered parameter, enabling multiple choice prompting at runtime.
    This behaviour is expected because commands often need to populate choice lists dynamically
    based on data queries or user context without re-registering parameters."""
    # Block 3.7.2.1: Import required modules
    from spafw37 import param
    from spafw37.constants.param import PARAM_NAME, PARAM_ALLOWED_VALUES
    
    # Block 3.7.2.2: Clear and register a param without allowed values
    param._params = {}
    test_param = {PARAM_NAME: 'choice_param'}
    param.add_param(test_param)
    
    # Block 3.7.2.3: Update allowed values dynamically
    param.set_allowed_values('choice_param', ['option_a', 'option_b', 'option_c'])
    
    # Block 3.7.2.4: Verify param definition was updated
    updated_param = param.get_param_by_name('choice_param')
    assert PARAM_ALLOWED_VALUES in updated_param, "PARAM_ALLOWED_VALUES should be added"
    assert updated_param[PARAM_ALLOWED_VALUES] == ['option_a', 'option_b', 'option_c'], "Values incorrect"
```

**Test 3.7.3: Tests for set_allowed_values with non-existent param**

```gherkin
Scenario: set_allowed_values with non-existent param raises ValueError
  Given no param named "nonexistent" is registered
  When set_allowed_values("nonexistent", ["a", "b"]) is called
  Then ValueError is raised
  And error message indicates parameter not found
  
  # Tests: Error handling for missing params
  # Validates: API fails clearly when param doesn't exist
```

```python
# Test 3.7.3: Add to tests/test_param_prompts.py
def test_set_allowed_values_raises_error_for_nonexistent_param():
    """Test that set_allowed_values() raises ValueError when parameter doesn't exist.
    
    This test verifies set_allowed_values() fails fast with clear error message when
    called with a parameter name that hasn't been registered.
    This behaviour is expected because updating allowed values on a non-existent parameter
    is a programming error that should be caught immediately rather than silently ignored."""
    # Block 3.7.3.1: Import required modules
    from spafw37 import param
    import pytest
    
    # Block 3.7.3.2: Clear all params
    param._params = {}
    
    # Block 3.7.3.3: Attempt to set allowed values on non-existent param
    with pytest.raises(ValueError, match="Parameter 'nonexistent' not found"):
        param.set_allowed_values('nonexistent', ['a', 'b'])
```

**Test 3.8.1: Regression test for params without PARAM_PROMPT**

```gherkin
Scenario: Params without PARAM_PROMPT register identically to before
  Given a param without PARAM_PROMPT property (standard param)
  When add_param() is called
  Then param is registered successfully
  And no prompt validation is performed
  And param behaves exactly as in previous framework versions
  
  # Tests: Regression - non-prompt params unchanged
  # Validates: Adding prompt support doesn't break existing param registration
```

```python
# Test 3.8.1: Add to tests/test_param_prompts.py
def test_params_without_prompt_register_unchanged():
    """Regression test: params without PARAM_PROMPT register identically to before.
    
    This test verifies that adding prompt support doesn't break existing parameter
    registration. Params without PARAM_PROMPT should register and behave exactly
    as they did before prompt functionality was added.
    This behaviour is expected because backward compatibility is critical - existing
    applications must continue to work without modification."""
    # Block 3.8.1.1: Clear any existing params
    param._params = {}
    
    # Block 3.8.1.2: Create standard param without PARAM_PROMPT
    standard_param = {
        PARAM_NAME: 'standard_param',
        PARAM_TYPE: PARAM_TYPE_TEXT,
        PARAM_DEFAULT: 'default_value',
        PARAM_ALLOWED_VALUES: ['option1', 'option2', 'option3']
    }
    
    # Block 3.8.1.3: Register param (should work exactly as before)
    param.add_param(standard_param)
    
    # Block 3.8.1.4: Verify param registered with all properties intact
    registered_param = param.get_param_by_name('standard_param')
    assert registered_param is not None, "Standard param should register"
    assert registered_param[PARAM_TYPE] == PARAM_TYPE_TEXT, "PARAM_TYPE preserved"
    assert registered_param[PARAM_DEFAULT] == 'default_value', "PARAM_DEFAULT preserved"
    assert registered_param[PARAM_ALLOWED_VALUES] == ['option1', 'option2', 'option3'], "PARAM_ALLOWED_VALUES preserved"
    
    # Block 3.8.1.5: Verify no prompt-related properties added automatically
    assert PARAM_PROMPT not in registered_param, "PARAM_PROMPT should not be added automatically"
    assert PARAM_PROMPT_TIMING not in registered_param, "PARAM_PROMPT_TIMING should not be added automatically"
```

**Test 3.8.2: Regression test for param validation behaviour**

```gherkin
Scenario: Existing param validation rules work unchanged
  Given a param without PARAM_PROMPT but with invalid PARAM_TYPE
  When add_param() is called
  Then validation error is raised exactly as before
  And error handling behaviour is unchanged
  
  # Tests: Regression - existing validation preserved
  # Validates: Prompt validation doesn't interfere with existing validation logic
```

```python
# Test 3.8.2: Add to tests/test_param_prompts.py
def test_existing_param_validation_unchanged():
    """Regression test: existing param validation rules work identically to before.
    
    This test verifies that adding prompt validation doesn't interfere with existing
    validation logic. Invalid params (missing required fields, invalid types, etc.)
    should fail validation exactly as they did before.
    This behaviour is expected because adding new validation for prompt properties
    must not change or break existing validation behaviour for non-prompt properties."""
    # Block 3.8.2.1: Clear any existing params
    param._params = {}
    
    # Block 3.8.2.2: Create param with missing required PARAM_NAME
    invalid_param = {
        # Missing PARAM_NAME - should fail validation
    }
    
    # Block 3.8.2.3: Verify existing validation still works
    with pytest.raises((ValueError, KeyError)):
        param.add_param(invalid_param)
```

**Test 3.8.3: Regression test for param operations on non-prompt params**

```gherkin
Scenario: get_param, set_param, and other operations work unchanged for non-prompt params
  Given a registered param without PARAM_PROMPT
  When get_param(), set_param(), and other param operations are used
  Then all operations work exactly as before
  And no prompt-related side effects occur
  
  # Tests: Regression - param operations unchanged
  # Validates: Adding prompt support doesn't alter existing param operation behaviour
```

```python
# Test 3.8.3: Add to tests/test_param_prompts.py
def test_param_operations_unchanged_for_non_prompt_params():
    """Regression test: param operations work identically for params without PARAM_PROMPT.
    
    This test verifies that get_param(), set_param(), and other param operations continue
    to work exactly as before for params without prompt configuration.
    This behaviour is expected because prompt functionality should be entirely opt-in
    through PARAM_PROMPT property - params without it should be completely unaffected."""
    # Block 3.8.3.1: Clear and register standard param
    param._params = {}
    test_param = {
        PARAM_NAME: 'counter',
        PARAM_TYPE: PARAM_TYPE_NUMBER
    }
    param.add_param(test_param)
    
    # Block 3.8.3.2: Test set_param() works unchanged
    param.set_param('counter', 42)
    
    # Block 3.8.3.3: Test get_param() works unchanged
    value = param.get_param('counter')
    assert value == 42, "get_param() should return set value"
    
    # Block 3.8.3.4: Test get_param_by_name() works unchanged
    param_def = param.get_param_by_name('counter')
    assert param_def is not None, "get_param_by_name() should return param definition"
    assert param_def[PARAM_NAME] == 'counter', "Param definition unchanged"
```

[↑ Back to top](#table-of-contents)

---

**Step 4.1: Process inline param definitions in COMMAND_PROMPT_PARAMS**

**File:** `src/spafw37/command.py`

**TODO:** Add implementation code here following the pattern from `COMMAND_REQUIRED_PARAMS` inline processing.

For each entry in `COMMAND_PROMPT_PARAMS`:
- If dict (inline definition): call `param._register_inline_param()` to register
- If string: use param name directly
- Normalise list to contain only param name strings
- Store normalised list back in `COMMAND_PROMPT_PARAMS`

**Test 4.1.1: test_inline_param_definitions_in_command_prompt_params**

This test validates that commands can define prompt params inline using dictionary definitions, consistent with inline definitions in `COMMAND_REQUIRED_PARAMS` and other fields. When a command includes inline param definitions in `COMMAND_PROMPT_PARAMS`, the framework should register those params automatically and establish the reciprocal relationship. This enables rapid prototyping without separately registering every prompt param.

```gherkin
Scenario: Command with inline param definitions in COMMAND_PROMPT_PARAMS
  Given a command "deploy" with COMMAND_PROMPT_PARAMS containing inline definitions:
    [{PARAM_NAME: "confirm", PARAM_TYPE: PARAM_TYPE_TOGGLE, PARAM_PROMPT: "Deploy? (y/n)"}]
  When command "deploy" is registered
  Then param "confirm" is automatically registered
  And param "confirm" has PARAM_PROMPT property set
  And param "confirm" has PROMPT_ON_COMMANDS ["deploy"]
  And command "deploy" has COMMAND_PROMPT_PARAMS ["confirm"]
  And reciprocal relationship established correctly
  
  # Tests: Inline param definitions in COMMAND_PROMPT_PARAMS
  # Validates: Consistent inline definition support across API
```

**Test 4.1.2: test_mixed_inline_and_named_in_command_prompt_params**

This test validates that commands can mix inline definitions and named references in `COMMAND_PROMPT_PARAMS`, consistent with the pattern used in `COMMAND_REQUIRED_PARAMS`. A command might reference some pre-registered params by name whilst defining others inline. The framework should handle both forms correctly in the same list, registering inline params and looking up named references.

```gherkin
Scenario: Command with mixed inline and named references in COMMAND_PROMPT_PARAMS
  Given a pre-registered param "username" with PARAM_PROMPT
  And a command "login" with COMMAND_PROMPT_PARAMS:
    ["username", {PARAM_NAME: "password", PARAM_TYPE: PARAM_TYPE_TEXT, PARAM_PROMPT: "Password:"}]
  When command "login" is registered
  Then param "password" is automatically registered from inline definition
  And param "username" is referenced by name (already registered)
  And both params have PROMPT_ON_COMMANDS ["login"]
  And command "login" has COMMAND_PROMPT_PARAMS ["username", "password"]
  
  # Tests: Mixed inline/named references in COMMAND_PROMPT_PARAMS
  # Validates: Framework handles both forms in same list
```

**Test 4.1.3: test_command_prompt_params_without_param_prompt_property**

This test validates that the framework enforces the requirement that params in `COMMAND_PROMPT_PARAMS` must have `PARAM_PROMPT` property. If a command explicitly lists a param in `COMMAND_PROMPT_PARAMS` but that param doesn't have `PARAM_PROMPT`, this is a configuration error that should be caught during registration. The test confirms the framework raises `ValueError` for this invalid configuration.

```gherkin
Scenario: Command COMMAND_PROMPT_PARAMS entry without PARAM_PROMPT raises error
  Given a param "config" registered without PARAM_PROMPT property
  And a command "process" with COMMAND_PROMPT_PARAMS ["config"]
  When command "process" is registered
  Then ValueError is raised
  And error message indicates param lacks PARAM_PROMPT property
  
  # Tests: Validation of COMMAND_PROMPT_PARAMS entries
  # Validates: Framework catches configuration errors during registration
```

[↑ Back to top](#table-of-contents)

---

**Step 4.2: Build reciprocal registration for required params**

**File:** `src/spafw37/command.py`

**TODO:** Add implementation code here for auto-population mechanism.

Initialize `COMMAND_PROMPT_PARAMS` as empty list on command definition (if not explicitly set). For each param name in `COMMAND_REQUIRED_PARAMS`:
- Look up param definition from `param._params`
- If param has `PARAM_PROMPT` and auto-population flag set:
  - Add this command name to param's `PROMPT_ON_COMMANDS` list
  - Clear auto-population flag after update
- If param has `PARAM_PROMPT` and this command in its `PROMPT_ON_COMMANDS`:
  - Add param name to command's `COMMAND_PROMPT_PARAMS` list

**Test 4.2.1: test_auto_population_from_command_required_params**

This test validates the auto-population mechanism that reduces configuration burden. When a param has `PARAM_PROMPT` but no explicit `PARAM_PROMPT_TIMING`, and a command lists that param in `COMMAND_REQUIRED_PARAMS`, the framework should automatically add the command name to the param's `PROMPT_ON_COMMANDS` list. This allows commands to trigger prompts for their required params without duplicate configuration. The test confirms auto-population works correctly during command registration.

```gherkin
Scenario: Param marked for auto-population gets command name added to PROMPT_ON_COMMANDS
  Given a param "input_val" with PARAM_PROMPT but no PARAM_PROMPT_TIMING
  And param is marked with auto-population flag during registration
  When a command "process" is registered with COMMAND_REQUIRED_PARAMS ["input_val"]
  Then param "input_val" has PROMPT_ON_COMMANDS updated to ["process"]
  And auto-population flag is cleared after update
  
  # Tests: Auto-population mechanism during command registration
  # Validates: Commands automatically trigger prompts for required params without explicit configuration
```

**Test 4.2.2: test_reciprocal_list_built_on_command**

This test validates that commands build their `COMMAND_PROMPT_PARAMS` list when registering. When a command's required params have `PARAM_PROMPT` with this command in their `PROMPT_ON_COMMANDS`, the framework should add those param names to the command's `COMMAND_PROMPT_PARAMS` list. This reciprocal list enables O(1) lookup during command execution—"which params need prompting before I run?"—without scanning all parameters. The test confirms the reciprocal list building works correctly.

```gherkin
Scenario: Command builds COMMAND_PROMPT_PARAMS from params that prompt before it
  Given a param "user_input" with PARAM_PROMPT and PROMPT_ON_COMMANDS ["execute"]
  When command "execute" is registered with COMMAND_REQUIRED_PARAMS ["user_input"]
  Then command "execute" has COMMAND_PROMPT_PARAMS ["user_input"]
  And reciprocal relationship established between param and command
  
  # Tests: Reciprocal list building on command side
  # Validates: Commands know which params will prompt before execution (O(1) lookup)
```

**Test 4.2.3: test_multiple_params_all_added_to_command**

This test validates that commands correctly handle multiple prompt-enabled required params. When a command requires several params that all have `PARAM_PROMPT`, the command's `COMMAND_PROMPT_PARAMS` list should contain all of them. This ensures complex commands with multiple interactive inputs work correctly. The test confirms the reciprocal list building scales to multiple parameters without dropping any.

```gherkin
Scenario: Command with multiple required params builds complete COMMAND_PROMPT_PARAMS list
  Given params "name", "age", "email" all with PARAM_PROMPT and auto-population flags
  When command "register" registered with COMMAND_REQUIRED_PARAMS ["name", "age", "email"]
  Then command "register" has COMMAND_PROMPT_PARAMS ["name", "age", "email"]
  And all three params have PROMPT_ON_COMMANDS ["register"]
  And all reciprocal relationships established correctly
  
  # Tests: Multiple param handling in reciprocal registration
  # Validates: Commands with multiple prompt params build complete reciprocal lists
```

[↑ Back to top](#table-of-contents)

---

**Step 4.3: Build reciprocal registration for explicit prompt params**

**File:** `src/spafw37/command.py`

**TODO:** Add implementation code here for explicit prompt param processing.

For each param name in `COMMAND_PROMPT_PARAMS` (after inline processing):
- Look up param definition from `param._params`
- If param has `PARAM_PROMPT` and `PROMPT_ON_COMMANDS` not set:
  - Add this command name to param's `PROMPT_ON_COMMANDS` list
- Ensure param has `PARAM_PROMPT` (raise error if missing)

**Test 4.3.1: test_param_with_multiple_commands_in_prompt_on_commands**

This test validates that params can explicitly list multiple commands in `PROMPT_ON_COMMANDS` and all reciprocal relationships are established. When a param specifies `PROMPT_ON_COMMANDS: ["cmd1", "cmd2", "cmd3"]`, all three commands should add this param to their `COMMAND_PROMPT_PARAMS` lists. This enables params to prompt before multiple different commands. The test confirms multi-command relationships work correctly.

```gherkin
Scenario: Param with explicit multi-command PROMPT_ON_COMMANDS creates multiple reciprocal links
  Given a param "confirm" with PARAM_PROMPT and PROMPT_ON_COMMANDS ["delete", "reset", "purge"]
  When commands "delete", "reset", "purge" are registered
  Then command "delete" has COMMAND_PROMPT_PARAMS including "confirm"
  And command "reset" has COMMAND_PROMPT_PARAMS including "confirm"
  And command "purge" has COMMAND_PROMPT_PARAMS including "confirm"
  
  # Tests: One-to-many param-command relationships
  # Validates: Single param can prompt before multiple commands with correct reciprocal links
```

**Test 4.3.2: test_param_without_prompt_property_no_reciprocal_building**

This test validates that the reciprocal registration mechanism only activates for prompt-enabled params. Params without `PARAM_PROMPT` should not trigger any reciprocal list building, even if they're in `COMMAND_REQUIRED_PARAMS`. This ensures the prompt system remains opt-in and doesn't affect non-interactive params. The test confirms params without `PARAM_PROMPT` are excluded from reciprocal registration.

```gherkin
Scenario: Param without PARAM_PROMPT does not trigger reciprocal list building
  Given a param "config_file" with no PARAM_PROMPT property
  When command "process" registered with COMMAND_REQUIRED_PARAMS ["config_file"]
  Then param "config_file" has no PROMPT_ON_COMMANDS list
  And command "process" has empty COMMAND_PROMPT_PARAMS list
  And no reciprocal relationship created
  
  # Tests: Opt-in nature of prompt system
  # Validates: Only params with PARAM_PROMPT participate in reciprocal registration
```

**Test 4.3.3: test_registration_order_independence**

This test validates that reciprocal registration works correctly regardless of whether params or commands are registered first. The framework should handle both scenarios: params registered before commands (forward reference) and commands registered before params (backward reference). This order independence prevents fragile registration sequences. The test confirms reciprocal lists are built correctly in both registration orders.

```gherkin
Scenario: Reciprocal registration works with both param-first and command-first order
  Given test runs twice with different registration orders
  
  # Order 1: Param first, then command
  When param "value" registered with PARAM_PROMPT and auto-population flag
  And then command "calc" registered with COMMAND_REQUIRED_PARAMS ["value"]
  Then reciprocal lists built correctly
  
  # Order 2: Command first, then param
  When command "calc" registered with COMMAND_REQUIRED_PARAMS ["value"]
  And then param "value" registered with PARAM_PROMPT and auto-population flag
  Then reciprocal lists built correctly (deferred until param registration)
  
  And both orders produce identical reciprocal relationship structures
  
  # Tests: Registration order independence
  # Validates: Reciprocal registration handles forward and backward references correctly
```

[↑ Back to top](#table-of-contents)

---

#### Phase 2: Prompt Execution

**Step 5.1: Implement handler resolution helper**

**File:** `src/spafw37/param.py` (or new `src/spafw37/prompt.py`)

**TODO:** Add implementation code for `_get_prompt_handler(param_def)` function.

Resolve handler in order of precedence:
1. Param-level: Return `param_def[PARAM_PROMPT_HANDLER]` if set
2. Global: Return `_global_prompt_handler` if set
3. Default: Return `input_prompt.prompt_for_value`

**Test 5.1.1: test_handler_resolution_param_level_precedence**

This test validates the handler resolution precedence order. When a param has `PARAM_PROMPT_HANDLER` set, that handler must take precedence over the global handler (set via `set_prompt_handler()`) and the default handler (`input_prompt.py`). This three-tier precedence system (param-level → global → default) enables fine-grained control whilst providing sensible defaults. The test confirms param-level handlers override all others.

```gherkin
Scenario: Param-level handler takes precedence over global and default handlers
  Given a param with PARAM_PROMPT_HANDLER set to custom_param_handler
  And global handler set to custom_global_handler via set_prompt_handler()
  And default handler is input_prompt.prompt_for_value
  When _get_prompt_handler(param_def) is called
  Then function returns custom_param_handler
  And global handler not used
  And default handler not used
  
  # Tests: Handler resolution precedence (param > global > default)
  # Validates: Param-specific handlers override global configuration
```

**Test 5.1.2: test_handler_resolution_global_precedence**

This test validates that the global handler takes precedence over the default handler when no param-level handler is set. Applications can call `set_prompt_handler()` to replace the default `input()` behaviour globally without modifying every param. The test confirms this middle tier of precedence works correctly, enabling application-wide handler customization whilst respecting param-specific overrides.

```gherkin
Scenario: Global handler takes precedence over default when no param-level handler
  Given a param with no PARAM_PROMPT_HANDLER property
  And global handler set to custom_global_handler via set_prompt_handler()
  And default handler is input_prompt.prompt_for_value
  When _get_prompt_handler(param_def) is called
  Then function returns custom_global_handler
  And default handler not used
  
  # Tests: Handler resolution precedence (global > default)
  # Validates: Global handler customization works without param-level overrides
```

**Test 5.1.3: test_handler_resolution_default_fallback**

This test validates the default handler fallback when neither param-level nor global handlers are set. The default handler (`input_prompt.prompt_for_value`) should always be available as the final fallback, ensuring prompts work out-of-the-box without configuration. The test confirms the resolution logic correctly falls through to the default when no customization is present.

```gherkin
Scenario: Default handler used when no param-level or global handler configured
  Given a param with no PARAM_PROMPT_HANDLER property
  And no global handler set (_global_prompt_handler is None)
  And default handler is input_prompt.prompt_for_value
  When _get_prompt_handler(param_def) is called
  Then function returns input_prompt.prompt_for_value
  And default handler provides out-of-box functionality
  
  # Tests: Default handler fallback
  # Validates: Prompts work without configuration using built-in handler
```

[↑ Back to top](#table-of-contents)

---

**Step 5.2: Implement prompt timing check helper**

**File:** `src/spafw37/param.py` (or new `src/spafw37/prompt.py`)

**TODO:** Add implementation code for `_should_prompt_param(param_def, command_name=None, check_value=True)` function.

Determine if prompting needed:
- Check if param has value (CLI override)
- Check `PARAM_PROMPT_TIMING` matches context (PROMPT_ON_START vs PROMPT_ON_COMMANDS)
- Check `PARAM_PROMPT_REPEAT` tracking in `_prompted_params` set
- Return True if prompt should execute, False otherwise

**Test 5.2.1: test_should_prompt_timing_on_start**

This test validates the timing check for `PROMPT_ON_START`. When a param has `PARAM_PROMPT_TIMING == PROMPT_ON_START`, the `_should_prompt_param()` function should return true (assuming param has no value and other conditions are met). This enables prompts immediately after CLI parsing. The test confirms the timing check correctly identifies start-timing prompts.

```gherkin
Scenario: Should prompt returns true for PROMPT_ON_START timing without command context
  Given a param with PARAM_PROMPT_TIMING == PROMPT_ON_START
  And param has no current value
  When _should_prompt_param(param_def, command_name=None) is called
  Then function returns True
  And prompt should execute at application start
  
  # Tests: Timing check for PROMPT_ON_START
  # Validates: Framework identifies params that prompt after CLI parsing
```

**Test 5.2.2: test_should_prompt_timing_on_commands_match**

This test validates the timing check for `PROMPT_ON_COMMANDS` when the current command name matches. When a param has `PROMPT_ON_COMMANDS` containing the executing command's name, `_should_prompt_param()` should return true. This enables command-specific prompts. The test confirms the timing check correctly matches command names against the param's list.

```gherkin
Scenario: Should prompt returns true when command name in PROMPT_ON_COMMANDS list
  Given a param with PROMPT_ON_COMMANDS ["process", "execute"]
  And param has no current value
  When _should_prompt_param(param_def, command_name="execute") is called
  Then function returns True
  And prompt should execute before "execute" command
  
  # Tests: Timing check for PROMPT_ON_COMMANDS with matching command
  # Validates: Framework identifies params that prompt before specific commands
```

**Test 5.2.3: test_should_prompt_timing_on_commands_no_match**

This test validates that `_should_prompt_param()` returns false when the command name doesn't match any in `PROMPT_ON_COMMANDS`. Prompts should only appear before the commands explicitly listed, not all commands. The test confirms the timing check correctly excludes commands not in the list.

```gherkin
Scenario: Should prompt returns false when command name not in PROMPT_ON_COMMANDS
  Given a param with PROMPT_ON_COMMANDS ["process", "execute"]
  And param has no current value
  When _should_prompt_param(param_def, command_name="other") is called
  Then function returns False
  And prompt should not execute before "other" command
  
  # Tests: Timing check exclusion for unlisted commands
  # Validates: Prompts only appear before explicitly listed commands
```

**Test 5.2.4: test_should_prompt_value_already_set**

This test validates the CLI override behaviour. When a param already has a value (set via CLI arguments), `_should_prompt_param()` should return false regardless of timing configuration. This implements the "if set, don't prompt" policy that prevents unnecessary prompts when users provide values upfront. The test confirms value checks short-circuit prompt execution.

```gherkin
Scenario: Should prompt returns false when param value already set via CLI
  Given a param with PARAM_PROMPT_TIMING == PROMPT_ON_START
  And param has current value "cli_value" (set via CLI)
  When _should_prompt_param(param_def, check_value=True) is called
  Then function returns False
  And prompt should not execute (CLI override in effect)
  
  # Tests: CLI override behaviour
  # Validates: Params set via CLI don't prompt (no confirmation needed)
```

**Test 5.2.5: test_should_prompt_repeat_never_second_call**

This test validates the `PROMPT_REPEAT_NEVER` behaviour. After a param has been prompted once (tracked in `_prompted_params` set), subsequent calls to `_should_prompt_param()` should return false. This ensures single-prompt behaviour for initialization values. The test confirms the tracking mechanism correctly prevents repeat prompts.

```gherkin
Scenario: Should prompt returns false on second call for PROMPT_REPEAT_NEVER
  Given a param with PARAM_PROMPT_REPEAT == PROMPT_REPEAT_NEVER
  And param name in _prompted_params set (already prompted once)
  When _should_prompt_param(param_def) is called
  Then function returns False
  And prompt should not repeat
  
  # Tests: PROMPT_REPEAT_NEVER tracking
  # Validates: Params marked as prompted once don't re-prompt
```

[↑ Back to top](#table-of-contents)

---

**Step 5.3: Implement prompt execution with validation helper**

**File:** `src/spafw37/param.py` (or new `src/spafw37/prompt.py`)

**TODO:** Add implementation code for `_execute_prompt_with_validation(param_def, handler)` function.

Run handler, validate, retry on error:
- Call handler function with param definition
- Validate result using framework validation functions
- On validation failure: show error, retry (up to max_retry limit)
- On max retry:
  - If required param: exit application with error
  - If optional param: set value to None and continue
- Set param value on success

**Test 5.3.1: test_execute_prompt_with_validation_success**

This test validates the happy path: user enters valid input, validation passes, param value is set. The `_execute_prompt_with_validation()` function should call the handler, validate the result using framework validation functions, and set the param value if validation succeeds. The test confirms successful prompt execution with valid input.

```gherkin
Scenario: Valid input accepted, validated, and param value set correctly
  Given a param with PARAM_TYPE_NUMBER and validation rules
  And stdin mocked with StringIO("42\n")
  And handler is default input_prompt.prompt_for_value
  When _execute_prompt_with_validation(param_def, handler) is called
  Then handler called once
  And validation functions called with "42"
  And validation passes
  And param value set to 42
  And function returns successfully
  
  # Tests: Successful prompt execution with validation
  # Validates: Valid input flows through handler → validation → param value
```

**Test 5.3.2: test_execute_prompt_with_validation_retry**

This test validates the retry logic when validation fails. After invalid input, the function should display an error message, call the handler again, and continue until valid input is received (up to max retry limit). The test confirms retry logic works correctly, allowing users to correct mistakes without restarting the application.

```gherkin
Scenario: Invalid input triggers retry, eventually accepts valid input
  Given a param with PARAM_TYPE_NUMBER
  And stdin mocked with StringIO("invalid\n42\n")
  And handler is default input_prompt.prompt_for_value
  And max retry limit is 3
  When _execute_prompt_with_validation(param_def, handler) is called
  Then handler called twice (once for "invalid", once for "42")
  And validation fails on first attempt with clear error message
  And validation passes on second attempt
  And param value set to 42
  
  # Tests: Validation retry logic
  # Validates: Users can correct invalid input without restarting
```

**Test 5.3.3: test_execute_prompt_max_retry_required_param**

This test validates the max retry behaviour for required params. When a required param fails validation max_retry times, the framework should exit the application with a clear error message. This prevents infinite retry loops whilst ensuring required values are always provided or the application fails predictably. The test confirms the exit behaviour for required params after max retries.

```gherkin
Scenario: Required param exits application after max retry limit reached
  Given a param with PARAM_REQUIRED == True
  And stdin mocked with StringIO("invalid1\ninvalid2\ninvalid3\n")
  And max retry limit is 3
  When _execute_prompt_with_validation(param_def, handler) is called
  Then handler called 3 times (max retries)
  And all three inputs fail validation
  And application exits with error message indicating max retries exceeded
  And param value not set
  
  # Tests: Max retry behaviour for required params
  # Validates: Required params force application exit after max retry failures
```

**Test 5.3.4: test_execute_prompt_max_retry_optional_param**

This test validates the max retry behaviour for optional params. When an optional param fails validation max_retry times, the framework should set the param value to `None` and continue execution. This allows applications to proceed with missing optional values without forcing exit. The test confirms optional params set to `None` after max retries rather than exiting.

```gherkin
Scenario: Optional param sets None and continues after max retry limit
  Given a param with PARAM_REQUIRED == False (optional)
  And stdin mocked with StringIO("invalid1\ninvalid2\ninvalid3\n")
  And max retry limit is 3
  When _execute_prompt_with_validation(param_def, handler) is called
  Then handler called 3 times (max retries)
  And all three inputs fail validation
  And param value set to None
  And function returns without exiting application
  
  # Tests: Max retry behaviour for optional params
  # Validates: Optional params set None after max retries (graceful degradation)
```

[↑ Back to top](#table-of-contents)

---

**Step 5.4: Implement prompt text formatting helper**

**File:** `src/spafw37/param.py` (or new `src/spafw37/prompt.py`)

**TODO:** Add implementation code for `_format_prompt_text(param_def)` function.

Build prompt string with default value:
- Start with `PARAM_PROMPT` text
- If `PARAM_DEFAULT` exists, append `[default: {value}]`
- Add trailing space for cursor positioning
- Return formatted string

**Test 5.4.1: test_format_prompt_text_with_default**

This test validates the prompt text formatting function when a default value exists. The formatted prompt should include the bash convention `[default: value]` to clearly indicate what will happen if the user presses Enter. The test confirms the formatting function produces correct output with default values displayed.

```gherkin
Scenario: Prompt text includes default value in bash convention format
  Given a param with PARAM_PROMPT "Enter name:" and PARAM_DEFAULT "John"
  When _format_prompt_text(param_def) is called
  Then function returns "Enter name: [default: John] "
  And format follows bash convention
  And trailing space included for cursor positioning
  
  # Tests: Prompt text formatting with defaults
  # Validates: Users see clear indication of default value behaviour
```

**Test 5.4.2: test_format_prompt_text_without_default**

This test validates the prompt text formatting when no default value exists. The formatted prompt should display just the prompt text without the `[default: ...]` indicator. The test confirms the formatting function handles missing defaults correctly.

```gherkin
Scenario: Prompt text without default value shows only prompt message
  Given a param with PARAM_PROMPT "Enter value:" and no PARAM_DEFAULT
  When _format_prompt_text(param_def) is called
  Then function returns "Enter value: "
  And no default indicator shown
  And trailing space included for cursor positioning
  
  # Tests: Prompt text formatting without defaults
  # Validates: Prompts without defaults display cleanly without extra brackets
```

[↑ Back to top](#table-of-contents)

---

**Step 6.1: Integrate PROMPT_ON_START timing in CLI workflow**

**File:** `src/spafw37/cli.py` or appropriate orchestration module

**TODO:** Add implementation code for PROMPT_ON_START integration.

After CLI parsing completes, before command execution:
- Iterate `param._params` dictionary
- For each param with `PARAM_PROMPT_TIMING == PROMPT_ON_START`:
  - Check if param has value (CLI didn't set it)
  - If no value, call `_execute_prompt_with_validation()`
  - Set param value from prompt result

**Integration point:** After `_parse_command_line()` returns, before command queue processing

**Test 6.1.1: test_prompt_on_start_basic_execution**

This test validates the fundamental PROMPT_ON_START workflow: param prompts after CLI parsing, user provides input, param value is set, command executes with the prompted value. This is the happy path for start-timing prompts. The test confirms the complete flow from prompt to command execution works correctly without any special conditions or edge cases.

```gherkin
Scenario: Param with PROMPT_ON_START prompts after CLI parsing before command execution
  Given a param "username" with PARAM_PROMPT and PROMPT_ON_START timing
  And a command "greet" that uses param "username"
  And stdin mocked with StringIO("Alice\n")
  When application runs with command line "greet"
  Then CLI parsing completes first
  And prompt appears with "Enter username:"
  And user input "Alice" captured and validated
  And param "username" value set to "Alice"
  And command "greet" executes with username="Alice"
  
  # Tests: Basic PROMPT_ON_START integration
  # Validates: Start-timing prompts work in complete CLI workflow
```

**Test 6.1.2: test_prompt_on_start_cli_override_skips_prompt**

This test validates the CLI override behaviour for PROMPT_ON_START. When a user provides a param value via command-line arguments, the prompt should be skipped entirely—no confirmation, no display. This implements the "if set, don't prompt" policy. The test confirms CLI values prevent prompts from appearing, ensuring predictable behaviour and respecting explicit user input.

```gherkin
Scenario: Param set via CLI skips PROMPT_ON_START prompt entirely
  Given a param "username" with PARAM_PROMPT and PROMPT_ON_START timing
  And a command "greet" that uses param "username"
  When application runs with command line "--username Bob greet"
  Then CLI parsing sets username="Bob"
  And prompt phase checks param has value
  And prompt skipped (CLI override in effect)
  And no stdin read occurs
  And command "greet" executes with username="Bob"
  
  # Tests: CLI override behaviour for PROMPT_ON_START
  # Validates: Command-line arguments prevent prompts (no confirmation needed)
```

**Test 6.1.3: test_prompt_on_start_multiple_params_sequential**

This test validates that multiple PROMPT_ON_START params prompt sequentially in a predictable order. When several params need prompting at start, users should see them one at a time, provide input for each, and the application should continue only after all prompts complete. The test confirms multiple start-timing prompts work correctly without interfering with each other.

```gherkin
Scenario: Multiple PROMPT_ON_START params prompt sequentially in order
  Given params "name", "age", "city" all with PARAM_PROMPT and PROMPT_ON_START
  And stdin mocked with StringIO("Alice\n30\nLondon\n")
  When application runs with command line "process"
  Then prompt 1 appears for "name", input "Alice" captured
  And prompt 2 appears for "age", input "30" captured
  And prompt 3 appears for "city", input "London" captured
  And all three params have values set
  And command "process" executes with all three values
  
  # Tests: Multiple PROMPT_ON_START params
  # Validates: Sequential prompting works without interference
```

**Test 6.1.4: test_prompt_on_start_required_validation_failure**

This test validates the required param validation integration. When a required param with PROMPT_ON_START fails validation after max retries, the framework should exit with a clear error message rather than proceeding with invalid/missing data. This ensures data integrity for required params. The test confirms the framework enforces required param constraints even with interactive prompts.

```gherkin
Scenario: Required param with PROMPT_ON_START exits after max retry validation failures
  Given a param "port" with PARAM_PROMPT, PROMPT_ON_START, PARAM_REQUIRED=True
  And param has validation rules (must be integer 1-65535)
  And stdin mocked with StringIO("invalid\nbad\nwrong\n")
  And max retry limit is 3
  When application runs
  Then three prompts occur, all inputs fail validation
  And application exits with error "Max retries exceeded for required param 'port'"
  And command execution does not occur
  
  # Tests: Required param validation with PROMPT_ON_START
  # Validates: Framework enforces required param constraints with prompts
```

**Test 6.1.5: test_prompt_on_start_optional_continues_after_failure**

This test validates graceful degradation for optional params. When an optional param with PROMPT_ON_START fails validation after max retries, the framework should set the param to None and continue execution. This allows applications to handle missing optional values without forcing exit. The test confirms optional params enable graceful degradation whilst still attempting to collect user input.

```gherkin
Scenario: Optional param with PROMPT_ON_START sets None after max retries and continues
  Given a param "theme" with PARAM_PROMPT, PROMPT_ON_START, PARAM_REQUIRED=False
  And stdin mocked with StringIO("invalid\nbad\nwrong\n")
  And max retry limit is 3
  When application runs with command "start"
  Then three prompts occur, all inputs fail validation
  And param "theme" set to None
  And application continues without exit
  And command "start" executes with theme=None
  
  # Tests: Optional param graceful degradation
  # Validates: Applications can continue with missing optional values
```

**Test 6.1.6: test_prompt_on_start_default_value_handling**

This test validates default value behaviour in PROMPT_ON_START prompts. When a param has a default value and the user presses Enter without typing, the default should be used automatically. The prompt should display the default using bash convention `[default: value]` so users know what will happen. The test confirms default value handling works correctly in the integrated workflow.

```gherkin
Scenario: Blank input with default value uses default in PROMPT_ON_START
  Given a param "language" with PARAM_PROMPT, PROMPT_ON_START, PARAM_DEFAULT="en"
  And stdin mocked with StringIO("\n")
  When application runs with command "configure"
  Then prompt displays "Enter language: [default: en]"
  And user presses Enter (blank input)
  And param "language" set to "en" (default)
  And command "configure" executes with language="en"
  
  # Tests: Default value handling in PROMPT_ON_START
  # Validates: Bash convention defaults work in integrated workflow
```

[↑ Back to top](#table-of-contents)

---

**Step 7.1: Integrate PROMPT_ON_COMMAND timing in command execution**

**File:** `src/spafw37/command.py` or appropriate command execution module

**TODO:** Add implementation code for PROMPT_ON_COMMAND integration.

Before each command action executes:
- Look up `COMMAND_PROMPT_PARAMS` on command definition (O(1))
- For each param in list:
  - Check `PARAM_PROMPT_REPEAT` setting and current value
  - If should prompt, call `_execute_prompt_with_validation()`
  - Update param value from prompt result

**Repeat behaviour implementation:**
- `PROMPT_REPEAT_ALWAYS`: Always prompt, show previous value as default
- `PROMPT_REPEAT_IF_BLANK`: Only prompt if value is None/empty
- `PROMPT_REPEAT_NEVER`: Check `_prompted_params` set, skip if already prompted

**Test 7.1.1: test_prompt_on_command_basic_execution**

This test validates the fundamental PROMPT_ON_COMMAND workflow: param prompts immediately before the specified command executes, user provides input, param value is set, command proceeds with the prompted value. This establishes the basic command-timing behaviour without repeat complexities. The test confirms prompts appear at the correct moment in the command execution pipeline.

```gherkin
Scenario: Param with PROMPT_ON_COMMAND timing prompts before specified command execution
  Given a param "confirm" with PARAM_PROMPT, PARAM_PROMPT_TIMING=PROMPT_ON_COMMAND, and PROMPT_ON_COMMANDS=["delete"]
  And commands "list" and "delete" registered
  And stdin mocked with StringIO("yes\n")
  When application runs with command line "list delete"
  Then command "list" executes first without prompting
  And before "delete" executes, prompt appears "Enter confirm:"
  And user input "yes" captured and validated
  And param "confirm" set to "yes"
  And command "delete" executes with confirm="yes"
  
  # Tests: Basic PROMPT_ON_COMMAND integration
  # Validates: Prompt appears immediately before command in execution pipeline
```

**Test 7.1.2: test_prompt_on_command_cli_override_skips_prompt**

This test validates CLI override behaviour for PROMPT_ON_COMMAND timing. When a param value is set via command-line arguments, prompts should be skipped even when the command is about to execute. This maintains the consistent "if set, don't prompt" policy across all timing modes. The test confirms CLI overrides work correctly with command-timing prompts.

```gherkin
Scenario: Param set via CLI skips PROMPT_ON_COMMAND prompt before command
  Given a param "confirm" with PARAM_PROMPT, PARAM_PROMPT_TIMING=PROMPT_ON_COMMAND, and PROMPT_ON_COMMANDS=["delete"]
  And stdin mocked with StringIO("") (empty, should not be read)
  When application runs with command line "--confirm yes delete"
  Then CLI parsing sets confirm="yes"
  And before "delete" executes, prompt check occurs
  And prompt skipped because value already set
  And no stdin read occurs
  And command "delete" executes with confirm="yes"
  
  # Tests: CLI override with PROMPT_ON_COMMAND
  # Validates: "If set, don't prompt" policy maintained with command timing
```

**Test 7.1.3: test_prompt_on_command_multiple_commands_in_list**

This test validates that a param can prompt before multiple different commands when listed in the `PROMPT_ON_COMMANDS` property. Each command in the list should trigger a prompt check (subject to repeat behaviour). This enables shared params that need confirmation before several sensitive operations. The test confirms multi-command lists work correctly.

```gherkin
Scenario: Param with multiple commands in PROMPT_ON_COMMANDS property prompts before each
  Given a param "confirm" with PARAM_PROMPT, PARAM_PROMPT_TIMING=PROMPT_ON_COMMAND, and PROMPT_ON_COMMANDS=["delete", "reset", "purge"]
  And PARAM_PROMPT_REPEAT=PROMPT_REPEAT_ALWAYS
  And stdin mocked with StringIO("yes\nyes\nyes\n")
  When application runs with command line "delete reset purge"
  Then before "delete", prompt appears, input "yes" captured
  And before "reset", prompt appears again, input "yes" captured
  And before "purge", prompt appears again, input "yes" captured
  And all three commands execute with confirm="yes"
  
  # Tests: Multiple commands in PROMPT_ON_COMMANDS property
  # Validates: Param can prompt before multiple different commands
```

[↑ Back to top](#table-of-contents)

---

**Step 7.2: Implement PROMPT_REPEAT_ALWAYS behaviour**

**File:** `src/spafw37/command.py` or appropriate command execution module

**TODO:** Add implementation code for PROMPT_REPEAT_ALWAYS.

Every time a listed command executes:
- Prompt always appears
- Display previous value as default
- User can confirm or change value

**Test 7.2.1: test_prompt_repeat_always_shows_previous_value**

This test validates PROMPT_REPEAT_ALWAYS behaviour. Every time a listed command executes, the prompt should appear and display the previous value as the default. This enables users to confirm or change the value on each execution. The test confirms REPEAT_ALWAYS prompts every time and preserves the previous value as the default.

```gherkin
Scenario: PROMPT_REPEAT_ALWAYS prompts before every command execution with previous value
  Given a param "action" with PARAM_PROMPT, PARAM_PROMPT_TIMING=PROMPT_ON_COMMAND, PROMPT_ON_COMMANDS=["step"]
  And PARAM_PROMPT_REPEAT=PROMPT_REPEAT_ALWAYS
  And stdin mocked with StringIO("first\nsecond\nthird\n")
  When application runs with command line "step step step"
  Then iteration 1: prompt appears, input "first", action="first"
  And iteration 2: prompt shows [default: first], input "second", action="second"
  And iteration 3: prompt shows [default: second], input "third", action="third"
  And all three executions complete with different values
  
  # Tests: PROMPT_REPEAT_ALWAYS behaviour
  # Validates: Every execution prompts, previous value shown as default
```

**Test 7.2.2: test_prompt_on_command_with_cycle_repeat_always**

This test validates PROMPT_ON_COMMAND behaviour in cycles with REPEAT_ALWAYS. Each cycle iteration should trigger a prompt before the command executes. This enables per-iteration confirmation or value changes in loops. The test confirms REPEAT_ALWAYS works correctly in cycle contexts, prompting on every iteration.

```gherkin
Scenario: REPEAT_ALWAYS in cycle prompts on every iteration
  Given a param "item" with PARAM_PROMPT, PARAM_PROMPT_TIMING=PROMPT_ON_COMMAND, PROMPT_ON_COMMANDS=["process_item"]
  And PARAM_PROMPT_REPEAT=PROMPT_REPEAT_ALWAYS
  And a cycle command that runs "process_item" 3 times
  And stdin mocked with StringIO("item1\nitem2\nitem3\n")
  When cycle executes
  Then cycle iteration 1: prompt appears, input "item1"
  And cycle iteration 2: prompt appears, input "item2"
  And cycle iteration 3: prompt appears, input "item3"
  And each iteration processes different value
  
  # Tests: REPEAT_ALWAYS in cycles
  # Validates: Per-iteration prompting works correctly in loops
```

[↑ Back to top](#table-of-contents)

---

**Step 7.3: Implement PROMPT_REPEAT_IF_BLANK behaviour**

**File:** `src/spafw37/command.py` or appropriate command execution module

**TODO:** Add implementation code for PROMPT_REPEAT_IF_BLANK.

Before command execution:
- Check if param value is None or empty
- If blank: prompt appears
- If set: skip prompt and reuse value

**Test 7.3.1: test_prompt_repeat_if_blank_prompts_when_blank_only**

This test validates PROMPT_REPEAT_IF_BLANK behaviour. The first execution should prompt (value is blank), subsequent executions should skip prompting if the value is still set. This enables efficient re-use of values whilst allowing re-prompting if the value gets cleared. The test confirms REPEAT_IF_BLANK only prompts when necessary.

```gherkin
Scenario: PROMPT_REPEAT_IF_BLANK prompts only when value is blank
  Given a param "token" with PARAM_PROMPT, PARAM_PROMPT_TIMING=PROMPT_ON_COMMAND, PROMPT_ON_COMMANDS=["api_call"]
  And PARAM_PROMPT_REPEAT=PROMPT_REPEAT_IF_BLANK
  And stdin mocked with StringIO("abc123\n")
  When application runs with command line "api_call api_call api_call"
  Then iteration 1: value blank, prompt appears, input "abc123" captured
  And iteration 2: value still "abc123", prompt skipped
  And iteration 3: value still "abc123", prompt skipped
  And all three executions use token="abc123"
  
  # Tests: PROMPT_REPEAT_IF_BLANK behaviour
  # Validates: Prompts only when value is blank, reuses set values
```

[↑ Back to top](#table-of-contents)

---

**Step 7.4: Implement PROMPT_REPEAT_NEVER behaviour**

**File:** `src/spafw37/command.py` or appropriate command execution module

**TODO:** Add implementation code for PROMPT_REPEAT_NEVER.

Before command execution:
- Check `_prompted_params` tracking set
- If param name in set: skip prompt
- If not in set: prompt appears, add to tracking set

**Test 7.4.1: test_prompt_repeat_never_prompts_once_then_stops**

This test validates PROMPT_REPEAT_NEVER behaviour. Only the first execution of a listed command should prompt; all subsequent executions should skip prompting entirely. This enables one-time initialization values. The test confirms REPEAT_NEVER prompts exactly once and tracks prompt state correctly across multiple executions.

```gherkin
Scenario: PROMPT_REPEAT_NEVER prompts once on first execution then never repeats
  Given a param "config" with PARAM_PROMPT, PARAM_PROMPT_TIMING=PROMPT_ON_COMMAND, PROMPT_ON_COMMANDS=["process"]
  And PARAM_PROMPT_REPEAT=PROMPT_REPEAT_NEVER
  And stdin mocked with StringIO("settings.json\n")
  When application runs with command line "process process process"
  Then iteration 1: prompt appears, input "settings.json" captured
  And param "config" added to _prompted_params tracking set
  And iteration 2: prompt skipped (already prompted), config="settings.json"
  And iteration 3: prompt skipped (already prompted), config="settings.json"
  And all three executions use same value
  
  # Tests: PROMPT_REPEAT_NEVER behaviour
  # Validates: Single prompt with persistent value across executions
```

[↑ Back to top](#table-of-contents)

---

**Step 7.5: Test command dependencies with prompts**

**File:** `tests/test_integration_prompts.py` (extend)

**TODO:** Add integration test code here.

**Test 7.5.1: test_prompt_on_command_command_queue_dependencies**

This test validates that prompts work correctly with command dependencies and sequencing. When commands have dependencies or specific execution orders, prompts should still appear at the right moment before each listed command executes. The test confirms prompt timing respects command orchestration logic and doesn't interfere with dependencies.

```gherkin
Scenario: Prompts respect command queue order and dependencies
  Given commands "prepare", "validate", "execute" with dependencies
  And param "mode" with PARAM_PROMPT, PARAM_PROMPT_TIMING=PROMPT_ON_COMMAND, PROMPT_ON_COMMANDS=["validate", "execute"]
  And stdin mocked with StringIO("strict\n")
  When command queue processes with dependencies
  Then "prepare" executes first (no prompt, not in list)
  And before "validate", prompt appears, input "strict" captured
  And "validate" executes with mode="strict"
  And before "execute", prompt check occurs (REPEAT_NEVER, already prompted)
  And "execute" executes with mode="strict" (same value)
  
  # Tests: Prompts with command dependencies
  # Validates: Prompt timing respects command orchestration
```

[↑ Back to top](#table-of-contents)

---

**Step 8a: Add cycle-specific tests**

**File:** `tests/test_integration_prompts.py` (extend)

**Tests:** Comprehensive tests for prompt behaviour in cycle contexts with all repeat options.

This step validates that the prompt system works correctly within spafw37's cycle infrastructure. Cycles repeat commands multiple times, creating unique challenges for prompt timing and repeat behaviour. These tests ensure all three repeat modes (ALWAYS, IF_BLANK, NEVER) work correctly in cycles, nested cycles maintain proper state, and CLI overrides prevent prompting across all iterations. Cycles are the most complex context for prompts due to iteration state management.

**Test 8.8.1: test_cycle_repeat_always_prompts_every_iteration**

This test validates PROMPT_REPEAT_ALWAYS behaviour in cycles. Each cycle iteration should prompt before the command executes, allowing users to provide different values or confirm the action on every iteration. This is useful for per-item confirmation workflows. The test confirms REPEAT_ALWAYS prompts on every cycle iteration without state interference between iterations.

```gherkin
Scenario: PROMPT_REPEAT_ALWAYS prompts on every cycle iteration with previous value
  Given a param "filename" with PARAM_PROMPT and PROMPT_ON_COMMANDS ["process"]
  And PARAM_PROMPT_REPEAT=PROMPT_REPEAT_ALWAYS
  And a cycle that runs "process" command 3 times
  And stdin mocked with StringIO("file1.txt\nfile2.txt\nfile3.txt\n")
  When cycle executes
  Then iteration 1: prompt appears, input "file1.txt"
  And iteration 2: prompt appears with [default: file1.txt], input "file2.txt"
  And iteration 3: prompt appears with [default: file2.txt], input "file3.txt"
  And each iteration processes with different filename
  
  # Tests: REPEAT_ALWAYS in cycles
  # Validates: Per-iteration prompting with default value preservation
```

**Test 8.8.2: test_cycle_repeat_if_blank_first_iteration_only**

This test validates PROMPT_REPEAT_IF_BLANK behaviour in cycles. Only the first iteration should prompt (value starts blank), and all subsequent iterations should reuse the same value without prompting. This is efficient for batch processing where the same parameter applies to all items. The test confirms REPEAT_IF_BLANK prompts once and reuses the value across iterations.

```gherkin
Scenario: PROMPT_REPEAT_IF_BLANK prompts first iteration then reuses value
  Given a param "format" with PARAM_PROMPT and PROMPT_ON_COMMANDS ["convert"]
  And PARAM_PROMPT_REPEAT=PROMPT_REPEAT_IF_BLANK
  And a cycle that runs "convert" command 5 times
  And stdin mocked with StringIO("json\n")
  When cycle executes
  Then iteration 1: value blank, prompt appears, input "json" captured
  And iteration 2-5: value set to "json", prompt skipped
  And all five iterations use format="json"
  
  # Tests: REPEAT_IF_BLANK in cycles
  # Validates: Single prompt with value reuse across all iterations
```

**Test 8.8.3: test_cycle_repeat_never_prompts_before_cycle_starts**

This test validates PROMPT_REPEAT_NEVER behaviour in cycles. The prompt should appear once before the cycle starts, and all iterations should use the same value without re-prompting. This enables initialization-style prompts for cycle parameters. The test confirms REPEAT_NEVER prompts once and the tracking state persists correctly throughout the cycle.

```gherkin
Scenario: PROMPT_REPEAT_NEVER prompts once before cycle starts
  Given a param "mode" with PARAM_PROMPT and PROMPT_ON_COMMANDS ["task"]
  And PARAM_PROMPT_REPEAT=PROMPT_REPEAT_NEVER
  And a cycle that runs "task" command 4 times
  And stdin mocked with StringIO("batch\n")
  When cycle executes
  Then before cycle iteration 1: prompt appears, input "batch" captured
  And param "mode" added to _prompted_params set
  And iterations 1-4: all execute with mode="batch", no prompts
  
  # Tests: REPEAT_NEVER in cycles
  # Validates: One-time initialization for cycle parameters
```

**Test 8.8.4: test_nested_cycles_repeat_behaviour_independent**

This test validates that nested cycles maintain independent prompt state. Inner and outer cycles should each respect their own repeat behaviour without interfering with each other. This ensures complex nested workflows work correctly. The test confirms nested cycles maintain separate prompt tracking and repeat behaviour operates correctly at each level.

```gherkin
Scenario: Nested cycles maintain independent prompt state and repeat behaviour
  Given outer param "batch" with PROMPT_REPEAT_NEVER for outer cycle command
  And inner param "item" with PROMPT_REPEAT_ALWAYS for inner cycle command
  And outer cycle runs 2 times, inner cycle runs 3 times per outer iteration
  And stdin mocked with StringIO("batch1\nitem1\nitem2\nitem3\nitem4\nitem5\nitem6\n")
  When nested cycles execute
  Then outer iteration 1 prompts once for "batch": "batch1"
  And inner iterations 1-3 each prompt for "item": "item1", "item2", "item3"
  And outer iteration 2 does not prompt (REPEAT_NEVER)
  And inner iterations 4-6 each prompt for "item": "item4", "item5", "item6"
  And prompt state tracked independently for each cycle level
  
  # Tests: Nested cycles with different repeat behaviours
  # Validates: Independent prompt state at each nesting level
```

**Test 8.8.5: test_cycle_with_cli_override_no_prompting**

This test validates that CLI overrides prevent prompting across all cycle iterations. When a param value is set via command-line arguments, no prompts should appear during the cycle regardless of repeat behaviour configuration. This maintains consistent CLI override semantics. The test confirms CLI values work correctly in cycle contexts without any prompting.

```gherkin
Scenario: CLI override prevents prompting across all cycle iterations
  Given a param "limit" with PARAM_PROMPT and PROMPT_ON_COMMANDS ["check"]
  And PARAM_PROMPT_REPEAT=PROMPT_REPEAT_ALWAYS (would normally prompt every time)
  And a cycle that runs "check" command 4 times
  And stdin mocked with StringIO("") (empty, should not be read)
  When application runs with command line "--limit 100 [cycle command]"
  Then CLI parsing sets limit="100"
  And all 4 cycle iterations execute with limit="100"
  And no prompts occur (CLI override in effect)
  And stdin never read
  
  # Tests: CLI override in cycles
  # Validates: Command-line arguments prevent all cycle prompts
```

[↑ Back to top](#table-of-contents)

---

**Step 8b: Add extensibility tests**

**File:** `tests/test_param_prompts.py` (extend)

**Tests:** Test custom handler functionality and extensibility system.

This step validates the extensibility architecture that allows applications to replace the default `input()` handler with custom logic. Custom handlers enable advanced scenarios like GUI prompts, API-based input, or specialized input validation. These tests ensure the three-tier precedence system (param-level → global → default) works correctly, handlers receive proper context, return values are processed correctly, and error handling is robust.

**Test 8.8.6: test_global_custom_handler_replaces_default**

This test validates that a global custom handler replaces the default `input()` handler for all prompts without param-specific handlers. Applications can call `set_prompt_handler(custom_function)` once to change prompt behaviour globally. The test confirms global handler registration works correctly and the custom handler is invoked instead of the default for all applicable prompts.

```gherkin
Scenario: Global custom handler used for all prompts without param-specific handlers
  Given a custom handler function gui_prompt(param_def)
  When set_prompt_handler(gui_prompt) is called
  And a param "name" with PARAM_PROMPT (no PARAM_PROMPT_HANDLER)
  And prompt execution occurs for "name"
  Then gui_prompt function is called with param definition
  And default input_prompt.prompt_for_value NOT called
  And return value from gui_prompt set as param value
  
  # Tests: Global handler registration and invocation
  # Validates: Applications can replace default handler globally
```

**Test 8.8.7: test_param_level_handler_overrides_global_and_default**

This test validates that param-specific handlers have highest precedence, overriding both global and default handlers. Individual params can specify `PARAM_PROMPT_HANDLER` for specialized input handling whilst other params use the global or default handler. The test confirms param-level handlers are invoked correctly and take precedence over all other handlers.

```gherkin
Scenario: Param-specific handler takes precedence over global and default
  Given a global handler set to global_custom_handler
  And param "password" with PARAM_PROMPT_HANDLER set to secure_input_handler
  And param "username" with PARAM_PROMPT (no handler, uses global)
  When prompts execute for both params
  Then "password" uses secure_input_handler (param-level)
  And "username" uses global_custom_handler (global fallback)
  And default input_prompt.prompt_for_value NOT used for either
  
  # Tests: Param-level handler precedence
  # Validates: Individual params can override global handler configuration
```

**Test 8.8.8: test_handler_precedence_chain_all_levels**

This test validates the complete three-tier precedence chain (param-level → global → default) in a single scenario. Different params should use different handlers based on what's configured. The test confirms the precedence resolution logic works correctly across all three levels simultaneously.

```gherkin
Scenario: Handler precedence chain resolves correctly across three levels
  Given set_prompt_handler(global_handler) called
  And param "special" with PARAM_PROMPT_HANDLER=special_handler (level 1)
  And param "normal" with PARAM_PROMPT only (level 2 - uses global)
  And param "default_test" with PARAM_PROMPT only
  When global handler is then cleared (set to None)
  Then "special" uses special_handler (param-level precedence)
  And "normal" uses global_handler (global precedence)
  And "default_test" uses input_prompt.prompt_for_value (default fallback)
  And precedence: param > global > default confirmed
  
  # Tests: Complete precedence chain
  # Validates: Three-tier handler resolution works correctly
```

**Test 8.8.9: test_custom_handler_receives_param_definition**

This test validates that custom handlers receive the complete param definition as context. Handlers need access to param properties like PARAM_TYPE, PARAM_DEFAULT, PARAM_ALLOWED_VALUES to provide appropriate prompts. The test confirms handlers receive the full param definition object with all properties intact.

```gherkin
Scenario: Custom handler receives complete param definition with all properties
  Given a custom handler that inspects its param_def argument
  And param "choice" with multiple properties:
    - PARAM_PROMPT="Select option:"
    - PARAM_TYPE=PARAM_TYPE_TEXT
    - PARAM_ALLOWED_VALUES=["a", "b", "c"]
    - PARAM_DEFAULT="a"
  When custom handler is invoked for "choice"
  Then param_def argument contains all properties
  And handler can access PARAM_PROMPT, PARAM_TYPE, etc.
  And handler uses properties to customize prompt behaviour
  
  # Tests: Handler receives param context
  # Validates: Custom handlers have access to all param configuration
```

**Test 8.8.10: test_custom_handler_return_value_sets_param**

This test validates that the return value from a custom handler is used as the param value. Handlers can perform custom input collection and return the result, which the framework should validate and set as the param value. The test confirms the handler return value flows correctly through validation and into param storage.

```gherkin
Scenario: Return value from custom handler validated and set as param value
  Given a custom handler that returns "custom_result"
  And param "data" with PARAM_PROMPT_HANDLER=custom_handler
  And param has validation rules
  When prompt execution occurs
  Then custom_handler called and returns "custom_result"
  And "custom_result" passed through framework validation
  And if validation passes, param "data" set to "custom_result"
  And command receives value from custom handler
  
  # Tests: Handler return value processing
  # Validates: Custom handler results validated and stored correctly
```

**Test 8.8.11: test_custom_handler_exceptions_handled_gracefully**

This test validates exception handling for custom handlers. If a custom handler raises an exception, the framework should catch it, log an appropriate error, and either retry or fail gracefully based on param requirements. Poor handler implementations shouldn't crash the entire application. The test confirms exception handling provides robust behaviour even with faulty handlers.

```gherkin
Scenario: Exceptions in custom handlers caught and handled gracefully
  Given a custom handler that raises ValueError("Handler error")
  And param "test" with PARAM_PROMPT_HANDLER=faulty_handler
  When prompt execution occurs
  Then ValueError raised by handler is caught
  And error logged with clear message "Custom handler error: Handler error"
  And if param PARAM_REQUIRED=True, application exits with clear error
  And if param optional, param set to None and execution continues
  
  # Tests: Custom handler exception handling
  # Validates: Faulty handlers don't crash application unexpectedly
```

[↑ Back to top](#table-of-contents)

---

#### Phase 3: Documentation and Final Testing

**Step 9: Regression testing**

**Files:** Existing test suite

Run full test suite to ensure no regressions:
- All existing param tests pass
- All existing command tests pass
- All existing cycle tests pass
- All existing CLI parsing tests pass
- Params without `PARAM_PROMPT` behave exactly as before
- Commands without prompt params behave exactly as before

[Detailed test specifications will be added in Step 3]

[↑ Back to top](#table-of-contents)

---

**Step 10: Update documentation**

**Files:** `doc/parameters.md`, `README.md`, `examples/params_prompts.py`

Add comprehensive documentation:
- **New param properties:** Usage guide for all `PARAM_PROMPT*` properties
- **Timing options:** Examples of `PROMPT_ON_START` vs `PROMPT_ON_COMMAND` with `PROMPT_ON_COMMANDS` property
- **Repeat behaviour:** Examples of each `PROMPT_REPEAT_*` option in cycles
- **Custom handlers:** Guide for implementing and registering custom prompt handlers
- **Multiple choice:** Dynamic population with `set_allowed_values()` examples
- **CLI override:** Explain how CLI args prevent prompting
- **Auto-population:** Document `PROMPT_ON_COMMANDS` property auto-population from `COMMAND_REQUIRED_PARAMS`
- **Inline definitions:** Document `COMMAND_PROMPT_PARAMS` inline definition support (see `examples/inline_definitions_basic.py` and `examples/inline_definitions_advanced.py` for pattern)
- **Complete examples:** Working examples demonstrating common use cases

**Note:** The `COMMAND_PROMPT_PARAMS` field supports inline parameter definitions, consistent with `COMMAND_REQUIRED_PARAMS`, `COMMAND_TRIGGER_PARAM`, and dependency fields. This allows commands to define prompt-enabled params directly within their definition without separate `add_param()` calls, enabling rapid prototyping whilst maintaining API consistency.

[Detailed documentation plan will be added in Step 5]

[↑ Back to top](#table-of-contents)

---

## Further Considerations

### 1. Design Pattern Research - RESOLVED

([#issuecomment-3587791560](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791560))

**Question:** How do other CLI frameworks handle interactive user input?

**Answer:** Use Python's built-in `input()` function as the default handler, with extensibility support.

**Implementation:**
- Default prompt handler implemented in new file `input_prompt.py` using `input()` function
- Extensible via `PARAM_PROMPT_HANDLER` property (per-param override) or `set_prompt_handler()` method (global override)
- **Text:** Use `input()` with string return value
- **Boolean:** Accept yes/no, y/n, true/false with case-insensitive matching
- **Number:** Use `input()` with int() or float() conversion, retry on ValueError
- **Multiple choice:** Display numbered list, accept either number or text value
- **Error handling:** Retry on invalid input with clear error message

**Rationale:** Python's built-in `input()` function is simple, requires no dependencies, works on all platforms, and is what most Python CLI tools use. Extensible design allows custom handlers for advanced use cases (GUI prompts, API-based input, etc.) whilst providing sensible default behaviour.

**Resolves:** Q7 (User Input Mechanism)

[↑ Back to top](#table-of-contents)

---

### 2. Architecture Approach Trade-offs - RESOLVED

([#issuecomment-3587791581](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791581))

**Question:** What are the pros and cons of each architecture approach?

**Answer:** Option A - Param-level approach.

**Design details:**
- Add `PARAM_PROMPT` property to param definitions (e.g., `{PARAM_PROMPT: "What is the air-speed velocity of an unladen swallow?"}`)
- Add `PARAM_PROMPT_HANDLER` property (optional) to override default prompt handler for specific params
- Add `set_prompt_handler()` method to `param.py` (delegated in `core.py`) to set global prompt handler function
- Default prompt handler (using `input()` function) will be implemented in new file `input_prompt.py`
- Use existing `PARAM_TYPE` to determine input handling:
  - `PARAM_TYPE_TEXT` - accepts any text input
  - `PARAM_TYPE_NUMBER` - validates numeric input
  - `PARAM_TYPE_TOGGLE` - accepts boolean values
- Multiple choice automatically enabled when `PARAM_ALLOWED_VALUES` is present:
  - Display numbered list of allowed values
  - User can enter either the text value or the corresponding number
  - List displayed automatically with assigned numbers
- **Inline definition support:** Commands can define prompt-enabled params inline in `COMMAND_PROMPT_PARAMS` using dictionary definitions, consistent with inline definitions in `COMMAND_REQUIRED_PARAMS`, `COMMAND_TRIGGER_PARAM`, and dependency fields. This enables rapid prototyping without separately registering every param.
- **Future consideration:** May expand to support lists with multiple choice (enter choices by number separated by spaces or commas) - provisional only

**Rationale:** Integrates with existing param system, validation, and type handling. Leverages existing properties where possible (`PARAM_TYPE`, `PARAM_ALLOWED_VALUES`). Extensible design allows custom prompt handlers for advanced use cases (GUI prompts, API-based input, etc.) whilst providing sensible default behaviour. Inline definition support maintains API consistency with existing framework patterns (see `examples/inline_definitions_basic.py` and `examples/inline_definitions_advanced.py`).

**Breaking changes:** Low (new optional properties only).

**Resolves:** Q1 (Architecture Approach)

[↑ Back to top](#table-of-contents)

---

### 3. Implementation Complexity Assessment - RESOLVED

([#issuecomment-3587791599](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791599))

**Question:** What is the relative complexity of different aspects of this feature?

**Answer:**

**Low complexity:**
- Text input with `input()` function ✅ (Decided: use Python's `input()` as default in `input_prompt.py`)
- Basic type conversion (only relevant for `get_param()` retrieval and multi-choice number resolution)
- CLI override behaviour ✅ (Decided: "if set, don't prompt")
- Prompt handler extensibility ✅ (Decided: `PARAM_PROMPT_HANDLER` property and `set_prompt_handler()` method)

**Medium complexity:**
- Type validation ✅ (Decided: use existing framework validation functions)
- Default handling ✅ (Decided: bash convention `[default: value]`, blank selects default)
- Retry logic ✅ (Decided: re-prompt on error, max retry limit with required/optional behaviour)
- Boolean/number parsing ✅ (Decided: use existing `INPUT_FILTER`, toggles use y/n with natural defaults)
- Multiple choice with static lists ✅ (Decided: use `PARAM_ALLOWED_VALUES`)
- Timing control ✅ (Decided: `PARAM_PROMPT_TIMING` with `PROMPT_ON_START` / `PROMPT_ON_COMMAND`, command list in `PROMPT_ON_COMMANDS` property)
- Cycle integration ✅ (Decided: `PARAM_PROMPT_REPEAT` with `PROMPT_REPEAT_ALWAYS` / `PROMPT_REPEAT_IF_BLANK` / `PROMPT_REPEAT_NEVER`)

**High complexity:**
- Multiple choice with dynamic population ✅ (Decided: new public API `set_allowed_values()` method)

**Very high complexity (deferred):**
- Command-driven population ❌ (Not implementing as special feature in this version, achievable via `set_allowed_values()`)

**Status:** All decisions made. Ready for implementation.

**Rationale:** Helps prioritise features and identify implementation risks. Most features leverage existing framework infrastructure, reducing complexity. Timing/cycle control moved to medium complexity due to clean param-level property design.

**Implementation:** Phased approach - core features first (text, validation, defaults, retries), then timing/cycle control, then advanced features (dynamic population).

**Resolves:** Q2, Q3, Q4, Q5, Q6, Q7, Q8

[↑ Back to top](#table-of-contents)

---

### 4. User Experience Considerations - RESOLVED

([#issuecomment-3587791616](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791616))

**Question:** How should prompts interact with existing framework features?

**Answer:** Several UX questions resolved:
- **Batch mode:** Interactive prompts incompatible with batch/automated execution by design. Missing required params fail with existing validation errors. No special handling needed.
- **Testing:** Mock user input using stdin redirection or test fixtures
- **Help text:** Add "Will prompt if not provided" to param description
- **Error messages:** Provide clear guidance when prompts fail or are unavailable (e.g., EOF, stdin closed)

**Note:** `--silent` suppresses console logging, not interactive prompts.

**Rationale:** Prompts must work seamlessly with existing framework features and not break automated workflows. Ensures framework remains scriptable.

**Implementation:** Depends on Q8 answer (RESOLVED) and overall architecture choice (RESOLVED).

**Resolves:** Q8 (Silent/Batch Mode)

[↑ Back to top](#table-of-contents)

---

### 5. Alternative Solutions - RESOLVED

([#issuecomment-3587791636](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791636))

**Question:** Should this be built into the framework at all?

**Answer:** Yes, this adds important functionality to the framework. Users can currently achieve interactive prompts by using Python's `input()` directly in command actions, using external prompt libraries (Click, Inquirer, PyInquirer), or creating helper functions in their application code. However, framework integration provides significant value through unified parameter handling, validation, and timing control.

**Rationale:** Whilst adding this increases complexity and maintenance burden, the complexity is manageable and the feature remains minimal risk due to:
- Single-threaded execution model
- Entirely opt-in behaviour (no impact on existing code)
- Complexity isolated behind simple helper method `is_prompt_required()` at command execution points
- Implementation complexity hidden in dedicated prompt handling functions

The additional complexity is justified by the benefits: integrated validation, type handling, timing control, cycle support, and extensible handler architecture. All complexity introduction points can be bypassed by a single check of `is_prompt_required()` when a command is dequeued and run—the complex logic is safely encapsulated in separate functions.

**Implementation:** Framework integration provides sufficient value over alternatives. Proceed with implementation as planned.

**Resolves:** Decision to proceed with framework integration

[↑ Back to top](#table-of-contents)

---

### 6. Backward Compatibility and Breaking Changes - RESOLVED

([#issuecomment-3587791658](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791658))

**Question:** What breaking changes might this introduce?

**Answer:** With param-level architecture chosen (see FC2), risk is **low to medium**:

**Low risk aspects:**
- New optional param properties (`PARAM_PROMPT`, `PARAM_PROMPT_HANDLER`, `PARAM_PROMPT_TIMING`, `PARAM_PROMPT_REPEAT`)
- New public API methods (`set_prompt_handler()`, `set_allowed_values()`)
- New file `input_prompt.py` containing default handler
- Existing params without these properties remain completely unaffected

**Medium risk aspects:**
- Param processing logic changes to check for and execute prompts
- Timing of param value availability (prompts occur before command execution)
- Interaction with existing validation and required param checking

**Mitigation:** All prompt functionality is opt-in. Params without `PARAM_PROMPT` property behave exactly as before. No changes to existing command execution flow for non-prompted params.

**Rationale:** Param-level approach with new optional properties minimises risk. Existing applications continue to work without modification.

**Implementation:** Comprehensive regression testing required to ensure no impact on existing param/command behaviour.

**Resolves:** Clarifies breaking change risk for chosen architecture

[↑ Back to top](#table-of-contents)

---

### 7. Testing Strategy - RESOLVED

([#issuecomment-3587791692](https://github.com/minouris/spafw37/issues/15#issuecomment-3587791692))

**Question:** How will interactive prompts be tested?

**Answer:** Mocking `stdin` is straightforward in Python and the project already uses pytest's `monkeypatch` fixture extensively (see `tests/test_core.py`). Interactive prompts can be tested using standard Python testing approaches.

**Implementation approach:**

**Simple stdin mocking with StringIO:**
```python
from io import StringIO
import sys

# In test function:
test_input = StringIO("user response\n")
monkeypatch.setattr('sys.stdin', test_input)
result = input_prompt_handler(param_def)  # Calls input() internally
assert result == "user response"
```

**Multiple inputs for retry logic:**
```python
# Test retry on invalid input, then valid input
test_inputs = StringIO("invalid\nvalid\n")
monkeypatch.setattr('sys.stdin', test_inputs)
result = prompt_with_validation(param_def)
assert result == "valid"
```

**EOF and error handling:**
```python
# Test EOF behaviour
empty_input = StringIO("")
monkeypatch.setattr('sys.stdin', empty_input)
with pytest.raises(EOFError):
    input_prompt_handler(param_def)
```

**Test structure:**
- **Unit tests (`tests/test_input_prompt.py`):** Test default handler in isolation with various input types, validation, and error conditions
- **Integration tests (`tests/test_param_prompts.py`):** Test prompt execution with timing/repeat settings, CLI override, validation integration
- **Cycle tests (`tests/test_integration_prompts.py`):** Test prompt behaviour in cycles with different repeat settings

**Test fixtures for common scenarios:**
- Valid input (text, number, toggle, multiple choice)
- Invalid input requiring retry
- EOF/interrupt conditions
- Default value selection (blank input)
- CLI override scenarios

**Rationale:** Python's `StringIO` provides simple, reliable stdin mocking. The project already uses `monkeypatch` extensively, so no new testing infrastructure required. Interactive code is straightforward to test with this approach.

**Implementation:** Use pytest with `monkeypatch` fixture and `StringIO` for stdin mocking. Create helper fixtures for common test scenarios to reduce boilerplate.

**Resolves:** Testing infrastructure and approach confirmed

[↑ Back to top](#table-of-contents)

## Fixing Regressions

[PENDING REVIEW - To be completed if regressions are discovered during testing]

## Implementation Plan Changes

[PENDING REVIEW - To be completed if plan changes during implementation]

## Documentation Updates

[PENDING REVIEW - To be completed in Step 5]

## CHANGES for v1.1.0 Release

**Note:** This section must follow the format specified in `features/CHANGES-TEMPLATE.md`. The content will be posted as the closing comment and consumed by the release workflow.

[PENDING REVIEW - To be completed in Step 6]

### Issues Closed

- #15: User Input Params

### Additions

[PENDING REVIEW - To be completed in Step 6]

### Removals

[PENDING REVIEW - To be completed in Step 6]

### Changes

[PENDING REVIEW - To be completed in Step 6]

### Migration

[PENDING REVIEW - To be completed in Step 6]

### Documentation

[PENDING REVIEW - To be completed in Step 6]

### Testing

[PENDING REVIEW - To be completed in Step 6]

---

Full changelog: https://github.com/minouris/spafw37/compare/v[PREV]...v1.1.0  
Issues: https://github.com/minouris/spafw37/issues/15
