name: Release

on:
  workflow_dispatch:  # Manual trigger only

jobs:
  # Step 0: Run tests first
  test:
    uses: ./.github/workflows/test.yml

  release:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: write  # For creating releases and pushing commits
    env:
      PYTHON_VERSION: '3.7.9'
      PY_PREFIX: ${{ github.workspace }}/.local/python-3.7.9
      PIP_CACHE_DIR: ${{ github.workspace }}/.cache/pip
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Full history for changelog generation
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Ensure cache directories exist
      run: |
        mkdir -p "${{ env.PY_PREFIX }}" "${{ env.PIP_CACHE_DIR }}"

    - name: Restore Python build & pip caches
      id: python-cache
      uses: actions/cache@v4
      with:
        path: |
          ${{ env.PY_PREFIX }}
          ${{ env.PIP_CACHE_DIR }}
        key: python-${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          python-${{ runner.os }}-${{ env.PYTHON_VERSION }}-

    - name: Install build dependencies
      if: steps.python-cache.outputs.cache-hit != 'true'
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential wget curl libssl-dev zlib1g-dev \
          libbz2-dev libreadline-dev libsqlite3-dev libncurses5-dev libgdbm-dev \
          libnss3-dev liblzma-dev libffi-dev uuid-dev

    - name: Build and install Python (only if cache miss)
      if: steps.python-cache.outputs.cache-hit != 'true'
      run: |
        set -euo pipefail
        PY=${{ env.PYTHON_VERSION }}
        mkdir -p $HOME/src
        cd $HOME/src
        wget --no-verbose https://www.python.org/ftp/python/${PY}/Python-${PY}.tgz
        tar xzf Python-${PY}.tgz
        cd Python-${PY}
        ./configure --prefix=$PY_PREFIX --with-ensurepip=install
        make -j "$(nproc)"
        make install     

    - name: Add built Python to PATH
      run: |
        echo "${{ env.PY_PREFIX }}/bin" >> $GITHUB_PATH

    - name: Verify Python
      run: |
        python3 --version
        python3 -m pip --version

    - name: Install dependencies
      run: |
        python3 -m pip install --upgrade pip setuptools wheel twine
        if [ -f requirements.txt ]; then python3 -m pip install -r requirements.txt; fi

    # Step 1: Remove .dev suffix from version
    - name: Get current version and remove .dev suffix
      id: version
      run: |
        VERSION=$(grep "^version = " setup.cfg | sed 's/version = //')
        echo "Current version: $VERSION"
        
        # Remove .devN suffix if present
        RELEASE_VERSION=$(echo "$VERSION" | sed 's/\.dev[0-9]*$//')
        echo "Release version: $RELEASE_VERSION"
        
        # Store for later steps
        echo "version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
        echo "previous_version=$VERSION" >> $GITHUB_OUTPUT
        
        # Update setup.cfg
        sed -i "s/^version = .*/version = $RELEASE_VERSION/" setup.cfg
        
        echo "Updated setup.cfg to version $RELEASE_VERSION"

    - name: Commit version change for release
      run: |
        git add setup.cfg
        git commit -m "Release version ${{ steps.version.outputs.version }} [skip ci]"

    # Step 4: Generate changelog (before tagging so it's included in the release)
    - name: Get previous release tag
      id: prev_tag
      run: |
        # Get the second-to-last tag (previous release)
        PREV_TAG=$(git tag --sort=-v:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sed -n '1p' || echo "")
        if [ -z "$PREV_TAG" ]; then
          echo "No previous release found, this is the first release"
          echo "prev_tag=" >> $GITHUB_OUTPUT
          echo "is_first=true" >> $GITHUB_OUTPUT
        else
          echo "Previous release tag: $PREV_TAG"
          echo "prev_tag=$PREV_TAG" >> $GITHUB_OUTPUT
          echo "is_first=false" >> $GITHUB_OUTPUT
        fi

    - name: Generate changelog with AI
      if: steps.prev_tag.outputs.is_first != 'true'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        PREV_TAG="${{ steps.prev_tag.outputs.prev_tag }}"
        CURRENT_TAG="v${{ steps.version.outputs.version }}"
        
        # Get the diff statistics and commit messages
        echo "Analyzing changes from ${PREV_TAG} to HEAD..."
        
        # Get diff stats
        DIFF_STATS=$(git diff --stat ${PREV_TAG}..HEAD)
        
        # Get commit messages with details
        COMMITS=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
        
        # Get changed files
        CHANGED_FILES=$(git diff --name-only ${PREV_TAG}..HEAD | head -20)
        
        # Create a prompt for the AI to summarize
        cat > /tmp/changelog_prompt.txt <<EOF
        Generate a concise, user-friendly changelog for version ${{ steps.version.outputs.version }} of the spafw37 Python framework.
        
        Review the following information and create a changelog that:
        1. Groups changes into categories (Added, Changed, Fixed, Removed, etc.)
        2. Uses clear, non-technical language where possible
        3. Highlights the most important changes first
        4. Keeps each bullet point concise (one line)
        5. Omits trivial changes like formatting or typos unless significant
        
        Commit messages:
        ${COMMITS}
        
        Changed files:
        ${CHANGED_FILES}
        
        Diff statistics:
        ${DIFF_STATS}
        
        Format the output as markdown suitable for a CHANGELOG.md file, starting with the changes (no header).
        EOF
        
        # Use GitHub Copilot API or fallback to structured commit list
        # Try to use gh cli with copilot extension if available
        if command -v gh &> /dev/null && gh copilot --version &> /dev/null 2>&1; then
          echo "Using GitHub Copilot to generate changelog..."
          CHANGELOG_CONTENT=$(gh copilot suggest "$(cat /tmp/changelog_prompt.txt)" 2>/dev/null || echo "")
        fi
        
        # Fallback: Use OpenAI API if OPENAI_API_KEY is set
        if [ -z "$CHANGELOG_CONTENT" ] && [ -n "${{ secrets.OPENAI_API_KEY }}" ]; then
          echo "Using OpenAI API to generate changelog..."
          CHANGELOG_CONTENT=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.OPENAI_API_KEY }}" \
            -d "{
              \"model\": \"gpt-4\",
              \"messages\": [{\"role\": \"user\", \"content\": $(jq -Rs . < /tmp/changelog_prompt.txt)}],
              \"temperature\": 0.3,
              \"max_tokens\": 1000
            }" | jq -r '.choices[0].message.content' 2>/dev/null || echo "")
        fi
        
        # Final fallback: Use structured commit list
        if [ -z "$CHANGELOG_CONTENT" ]; then
          echo "Using structured commit list (AI not available)..."
          CHANGELOG_CONTENT="### Changes

        ${COMMITS}
        
        *For detailed changes, see the [commit history](https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${CURRENT_TAG}).*"
        fi
        
        # Build the new changelog
        echo "# Changelog" > CHANGELOG.new.md
        echo "" >> CHANGELOG.new.md
        echo "## [${{ steps.version.outputs.version }}] - $(date +%Y-%m-%d)" >> CHANGELOG.new.md
        echo "" >> CHANGELOG.new.md
        echo "${CHANGELOG_CONTENT}" >> CHANGELOG.new.md
        echo "" >> CHANGELOG.new.md
        
        # Append existing changelog if it exists
        if [ -f CHANGELOG.md ]; then
          tail -n +2 CHANGELOG.md >> CHANGELOG.new.md
        fi
        
        mv CHANGELOG.new.md CHANGELOG.md
        
        echo "Changelog generated successfully"

    - name: Create initial changelog
      if: steps.prev_tag.outputs.is_first == 'true'
      run: |
        echo "# Changelog" > CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "## [${{ steps.version.outputs.version }}] - $(date +%Y-%m-%d)" >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "Initial release" >> CHANGELOG.md
        echo "" >> CHANGELOG.md

    - name: Commit changelog
      run: |
        git add CHANGELOG.md
        git commit -m "Update CHANGELOG.md for v${{ steps.version.outputs.version }} [skip ci]" || echo "No changelog changes to commit"

    # Step 2: Create git tag and release (after changelog is committed)
    - name: Create git tag
      run: |
        git tag -a "v${{ steps.version.outputs.version }}" -m "Release v${{ steps.version.outputs.version }}  [skip ci]"
        git push origin "v${{ steps.version.outputs.version }}"

    - name: Create bugfix branch from tag
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        # Parse version to get major.minor (e.g., 1.0.0 -> 1.0)
        IFS='.' read -r major minor patch <<< "$VERSION"
        BRANCH_NAME="bugfix/${major}.${minor}.x"
        
        echo "Creating bugfix branch: $BRANCH_NAME"
        
        # Create branch from the tag
        git checkout -b "$BRANCH_NAME" "v${{ steps.version.outputs.version }}"
        
        # Push the branch
        git push origin "$BRANCH_NAME"
        
        # Return to main
        git checkout main

    # Step 3: Build and deploy to PyPI from the tag
    - name: Build distribution packages
      run: |
        python3 -m pip install --upgrade build
        python3 -m build

    - name: Publish to PyPI
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
      run: |
        python3 -m twine upload dist/*

    # Step 5: Increment version and add .dev0 suffix
    - name: Increment version for next development cycle
      id: next_version
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        echo "Current release version: $VERSION"
        
        # Parse version components (X.Y.Z)
        IFS='.' read -r major minor patch <<< "$VERSION"
        
        # Increment patch version
        next_patch=$((patch + 1))
        NEXT_VERSION="${major}.${minor}.${next_patch}.dev0"
        
        echo "Next development version: $NEXT_VERSION"
        echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
        
        # Update setup.cfg
        sed -i "s/^version = .*/version = $NEXT_VERSION/" setup.cfg

    # Step 6: Commit version bump back to main
    - name: Commit development version
      run: |
        git add setup.cfg
        git commit -m "Bump version to ${{ steps.next_version.outputs.next_version }} [skip ci]"
        git push origin main

    # Create GitHub Release
    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ steps.version.outputs.version }}
        release_name: Release v${{ steps.version.outputs.version }}
        body: |
          Release of spafw37 version ${{ steps.version.outputs.version }}
          
          Install with:
          ```
          pip install spafw37==${{ steps.version.outputs.version }}
          ```
          
          See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for details.
        draft: false
        prerelease: false
