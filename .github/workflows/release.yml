name: Release

on:
  workflow_dispatch:
    inputs:
      mode:
        description: 'Release mode'
        required: true
        type: choice
        options:
          - full-release
          - docs-only
        default: 'full-release'
      dry_run:
        description: 'Dry run (skip git push and PyPI publish)'
        required: false
        type: boolean
        default: false

jobs:
  # Step 0: Run tests first
  test:
    uses: ./.github/workflows/test.yml
    with:
      python_version: '3.7.9'
      coverage_threshold: ${{ inputs.mode == 'full-release' && 95 || 80 }}

  # Prepare Python build/cache so later jobs can restore it
  prepare-python:
    needs: test
    uses: ./.github/workflows/build-python.yml
    with:
      python_version: '3.7.9'

  release:
    needs: [test, prepare-python]
    outputs:
      version: ${{ steps.version.outputs.version }}
      release_mode: ${{ env.RELEASE_MODE }}
      dry_run: ${{ inputs.dry_run }}
    runs-on: ubuntu-latest
    permissions:
      contents: write  # For creating releases and pushing commits
      id-token: write  # For PyPI Trusted Publisher OIDC
    env:
      PYTHON_VERSION: '3.7.9'
      PY_PREFIX: ${{ github.workspace }}/.local/python-3.7.9
      PIP_CACHE_DIR: ${{ github.workspace }}/.cache/pip
      RELEASE_MODE: ${{ inputs.mode }}
      DRY_RUN: ${{ inputs.dry_run }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Full history for changelog generation
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Ensure cache directories exist
      run: |
        mkdir -p "${{ env.PY_PREFIX }}" "${{ env.PIP_CACHE_DIR }}"

    - name: Restore Python build & pip caches
      id: python-cache
      uses: actions/cache@v4
      with:
        path: |
          ${{ env.PY_PREFIX }}
          ${{ env.PIP_CACHE_DIR }}
        key: python-${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          python-${{ runner.os }}-${{ env.PYTHON_VERSION }}-

    # Python build is prepared by `prepare-python` reusable job and restored from cache here

    - name: Add built Python to PATH
      run: |
        echo "${{ env.PY_PREFIX }}/bin" >> $GITHUB_PATH

    - name: Verify Python
      run: |
        python3 --version
        python3 -m pip --version

    - name: Install dependencies
      run: |
        python3 -m pip install --upgrade pip setuptools wheel twine
        if [ -f requirements.txt ]; then python3 -m pip install -r requirements.txt; fi

    # Step 2: Get version and create release branch
    - name: Get current version
      id: version
      run: |
        VERSION=$(grep "^version = " setup.cfg | sed 's/version = //')
        echo "Current version: $VERSION"
        
        # Remove .devN suffix if present
        RELEASE_VERSION=$(echo "$VERSION" | sed 's/\.dev[0-9]*$//')
        echo "Release version: $RELEASE_VERSION"
        
        # Store for later steps
        echo "version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
        echo "previous_version=$VERSION" >> $GITHUB_OUTPUT

    - name: Create release branch
      if: env.RELEASE_MODE == 'full-release'
      run: |
        TAG="v${{ steps.version.outputs.version }}"
        BRANCH_NAME="release/${TAG}"
        
        echo "Creating release branch: ${BRANCH_NAME}"
        git checkout -b "${BRANCH_NAME}"
        if [ "${{ inputs.dry_run }}" != "true" ]; then
          git push origin "${BRANCH_NAME}"
        else
          echo "[DRY RUN] Skipping: git push origin ${BRANCH_NAME}"
        fi

    # Step 3: Remove .dev suffix from version on release branch
    - name: Remove .dev suffix from version
      if: env.RELEASE_MODE == 'full-release'
      run: |
        RELEASE_VERSION="${{ steps.version.outputs.version }}"
        
        # Update setup.cfg
        sed -i "s/^version = .*/version = $RELEASE_VERSION/" setup.cfg
        
        echo "Updated setup.cfg to version $RELEASE_VERSION"
        
        git add setup.cfg
        git commit -m "Release version $RELEASE_VERSION [skip ci]" || echo "No changes to commit"

    # Step 4: Generate changelog on release branch
    - name: Get previous release tag
      if: env.RELEASE_MODE == 'full-release'
      id: prev_tag
      run: |
        # Get the second-to-last tag (previous release)
        PREV_TAG=$(git tag --sort=-v:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sed -n '1p' || echo "")
        if [ -z "$PREV_TAG" ]; then
          echo "No previous release found, this is the first release"
          echo "prev_tag=" >> $GITHUB_OUTPUT
          echo "is_first=true" >> $GITHUB_OUTPUT
        else
          echo "Previous release tag: $PREV_TAG"
          echo "prev_tag=$PREV_TAG" >> $GITHUB_OUTPUT
          echo "is_first=false" >> $GITHUB_OUTPUT
        fi

    - name: Generate changelog with AI
      if: env.RELEASE_MODE == 'full-release' && steps.prev_tag.outputs.is_first != 'true'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        PREV_TAG="${{ steps.prev_tag.outputs.prev_tag }}"
        CURRENT_TAG="v${{ steps.version.outputs.version }}"
        
        # Get the diff statistics and commit messages
        echo "Analysing changes from ${PREV_TAG} to HEAD..."
        
        # Get diff stats
        DIFF_STATS=$(git diff --stat ${PREV_TAG}..HEAD)
        
        # Get commit messages with details
        COMMITS=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
        
        # Get changed files
        CHANGED_FILES=$(git diff --name-only ${PREV_TAG}..HEAD | head -20)
        
        # Create a prompt for the AI to summarize
        cat > /tmp/changelog_prompt.txt <<EOF
        Generate a concise, user-friendly changelog for version ${{ steps.version.outputs.version }} of the spafw37 Python framework.
        
        Review the following information and create a changelog that:
        1. Groups changes into categories (Added, Changed, Fixed, Removed, etc.)
        2. Uses clear, non-technical language where possible
        3. Highlights the most important changes first
        4. Keeps each bullet point concise (one line)
        5. Omits trivial changes like formatting or typos unless significant
        
        Commit messages:
        ${COMMITS}
        
        Changed files:
        ${CHANGED_FILES}
        
        Diff statistics:
        ${DIFF_STATS}
        
        Format the output as markdown suitable for a CHANGELOG.md file, starting with the changes (no header).
        EOF
        
        # Use GitHub Copilot API or fallback to structured commit list
        # Try to use gh cli with copilot extension if available
        if command -v gh &> /dev/null && gh copilot --version &> /dev/null 2>&1; then
          echo "Using GitHub Copilot to generate changelog..."
          CHANGELOG_CONTENT=$(gh copilot suggest "$(cat /tmp/changelog_prompt.txt)" 2>/dev/null || echo "")
        fi
        
        # Fallback: Use OpenAI API if OPENAI_API_KEY is set
        if [ -z "$CHANGELOG_CONTENT" ] && [ -n "${{ secrets.OPENAI_API_KEY }}" ]; then
          echo "Using OpenAI API to generate changelog..."
          CHANGELOG_CONTENT=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.OPENAI_API_KEY }}" \
            -d "{
              \"model\": \"gpt-4\",
              \"messages\": [{\"role\": \"user\", \"content\": $(jq -Rs . < /tmp/changelog_prompt.txt)}],
              \"temperature\": 0.3,
              \"max_tokens\": 1000
            }" | jq -r '.choices[0].message.content' 2>/dev/null || echo "")
        fi
        
        # Final fallback: Use structured commit list
        if [ -z "$CHANGELOG_CONTENT" ]; then
          echo "Using structured commit list (AI not available)..."
          CHANGELOG_CONTENT="### Changes

        ${COMMITS}
        
        *For detailed changes, see the [commit history](https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${CURRENT_TAG}).*"
        fi
        
        # Build the new changelog
        echo "# Changelog" > CHANGELOG.new.md
        echo "" >> CHANGELOG.new.md
        echo "## [${{ steps.version.outputs.version }}] - $(date +%Y-%m-%d)" >> CHANGELOG.new.md
        echo "" >> CHANGELOG.new.md
        echo "${CHANGELOG_CONTENT}" >> CHANGELOG.new.md
        echo "" >> CHANGELOG.new.md
        
        # Append existing changelog if it exists
        if [ -f CHANGELOG.md ]; then
          tail -n +2 CHANGELOG.md >> CHANGELOG.new.md
        fi
        
        mv CHANGELOG.new.md CHANGELOG.md
        
        echo "Changelog generated successfully"

    - name: Create initial changelog
      if: env.RELEASE_MODE == 'full-release' && steps.prev_tag.outputs.is_first == 'true'
      run: |
        echo "# Changelog" > CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "## [${{ steps.version.outputs.version }}] - $(date +%Y-%m-%d)" >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "Initial release" >> CHANGELOG.md
        echo "" >> CHANGELOG.md

    - name: Commit changelog
      if: env.RELEASE_MODE == 'full-release'
      run: |
        git add CHANGELOG.md
        git commit -m "Update CHANGELOG.md for v${{ steps.version.outputs.version }} [skip ci]" || echo "No changelog changes to commit"
        
        # Push release branch with version and changelog changes
        TAG="v${{ steps.version.outputs.version }}"
        if [ "${{ inputs.dry_run }}" != "true" ]; then
          git push origin "release/${TAG}"
        else
          echo "[DRY RUN] Skipping: git push origin release/${TAG}"
        fi

    # Step 5: Update README links to point to tagged versions (separate commit, not merged to main)
    - name: Update README links to tagged documentation
      if: env.RELEASE_MODE == 'full-release'
      run: |
        TAG="v${{ steps.version.outputs.version }}"
        
        echo "Updating README.md links from /main/ to /${TAG}/"
        
        # Replace /tree/main/ with /tree/${TAG}/
        sed -i "s|/tree/main/|/tree/${TAG}/|g" README.md
        
        # Replace /blob/main/ with /blob/${TAG}/
        sed -i "s|/blob/main/|/blob/${TAG}/|g" README.md
        
        # Commit the README changes (this commit won't be merged to main)
        git add README.md
        git commit -m "Update README links to ${TAG} for tag [skip ci]" || echo "No README changes to commit"
        
        # Push this commit to release branch
        if [ "${{ inputs.dry_run }}" != "true" ]; then
          git push origin "release/${TAG}"
        else
          echo "[DRY RUN] Skipping: git push origin release/${TAG}"
        fi

    # Step 6: Create git tag from release branch (includes README with tagged links)
    - name: Create git tag
      if: env.RELEASE_MODE == 'full-release'
      run: |
        # Tag is created from current branch (release/vX.Y.Z) which has README with tagged links
        git tag -a "v${{ steps.version.outputs.version }}" -m "Release v${{ steps.version.outputs.version }} [skip ci]"
        if [ "${{ inputs.dry_run }}" != "true" ]; then
          git push origin "v${{ steps.version.outputs.version }}"
        else
          echo "[DRY RUN] Skipping: git push origin v${{ steps.version.outputs.version }}"
        fi

    # Step 7: Create bugfix branch from tag
    - name: Create bugfix branch from tag
      if: env.RELEASE_MODE == 'full-release'
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        # Parse version to get major.minor (e.g., 1.0.0 -> 1.0)
        IFS='.' read -r major minor patch <<< "$VERSION"
        BRANCH_NAME="bugfix/${major}.${minor}.x"
        
        echo "Creating bugfix branch: $BRANCH_NAME"
        
        # Create branch from the tag
        git checkout -b "$BRANCH_NAME" "v${{ steps.version.outputs.version }}"
        
        # Push the branch
        if [ "${{ inputs.dry_run }}" != "true" ]; then
          git push origin "$BRANCH_NAME"
        else
          echo "[DRY RUN] Skipping: git push origin $BRANCH_NAME"
        fi

    # Step 8: Merge release branch back to main (without README link changes)
    - name: Merge release branch to main
      if: env.RELEASE_MODE == 'full-release'
      run: |
        TAG="v${{ steps.version.outputs.version }}"
        
        # Checkout main
        git checkout main
        git pull origin main
        
        # Merge release branch, stopping before the README commit
        # We want version and changelog changes, but not README link changes
        git merge "release/${TAG}~1" --no-ff -m "Merge release ${TAG} to main [skip ci]"
        
        # Push to main
        if [ "${{ inputs.dry_run }}" != "true" ]; then
          git push origin main
        else
          echo "[DRY RUN] Skipping: git push origin main"
        fi

  # Step 9: Packaging using reusable build-and-verify workflow
  packaging:
    needs: [release, prepare-python]
    uses: ./.github/workflows/build-and-verify.yml
    with:
      python_version: '3.7.9'
      require_sdist: true

  # Step 10: Publish to PyPI (uses artifact produced by packaging)
  pypi_publish:
    needs: packaging
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Download dist artifact
      uses: actions/download-artifact@v3
      with:
        name: dist
        path: dist

    - name: List distribution artifacts
      run: |
        echo "Files in dist/"
        ls -la dist || true

    - name: Publish to PyPI
      id: pypi_publish
      if: ${{ needs.release.outputs.dry_run != 'true' }}
      continue-on-error: true
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        skip-existing: true

    - name: Dry run - Skip PyPI publish
      if: ${{ needs.release.outputs.dry_run == 'true' }}
      run: |
        echo "[DRY RUN] Skipping PyPI publish"
        echo "Would publish the following files:"
        ls -lh dist/

  # Step 11: Post-publish tasks (version bump, create GitHub Release, summary)
  post_publish:
    needs: [pypi_publish, release]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Increment version for next development cycle
      if: ${{ needs.release.outputs.release_mode == 'full-release' }}
      id: next_version
      run: |
        git checkout main
        git pull origin main
        VERSION="${{ needs.release.outputs.version }}"
        IFS='.' read -r major minor patch <<< "$VERSION"
        next_patch=$((patch + 1))
        NEXT_VERSION="${major}.${minor}.${next_patch}.dev0"
        echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
        sed -i "s/^version = .*/version = $NEXT_VERSION/" setup.cfg

    - name: Commit development version
      if: ${{ needs.release.outputs.release_mode == 'full-release' }}
      run: |
        git add setup.cfg
        git commit -m "Bump version to ${{ steps.next_version.outputs.next_version }} [skip ci]" || echo "No version changes to commit"
        if [ "${{ needs.release.outputs.dry_run }}" != "true" ]; then
          git push origin main
        else
          echo "[DRY RUN] Skipping: git push origin main (version bump)"
        fi

    - name: Create GitHub Release
      if: ${{ needs.release.outputs.release_mode == 'full-release' && needs.release.outputs.dry_run != 'true' }}
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ needs.release.outputs.version }}
        release_name: Release v${{ needs.release.outputs.version }}
        body: |
          Release of spafw37 version ${{ needs.release.outputs.version }}
        draft: false
        prerelease: false

    - name: Dry run - Skip GitHub Release
      if: ${{ needs.release.outputs.release_mode == 'full-release' && needs.release.outputs.dry_run == 'true' }}
      run: |
        echo "[DRY RUN] Skipping GitHub Release creation"
        echo "Would create release: v${{ needs.release.outputs.version }}"

    - name: Release Summary
      if: always()
      run: |
        echo "## Release Workflow Summary" >> $GITHUB_STEP_SUMMARY
        echo "**Mode:** ${{ needs.release.outputs.release_mode }}" >> $GITHUB_STEP_SUMMARY
        echo "**Version:** ${{ needs.release.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "**Dry Run:** ${{ needs.release.outputs.dry_run }}" >> $GITHUB_STEP_SUMMARY
        if [ "${{ needs.release.outputs.dry_run }}" == "true" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "⚠️ **This was a dry run - no permanent changes were made**" >> $GITHUB_STEP_SUMMARY
        fi
