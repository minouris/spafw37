name: Release

on:
  workflow_dispatch:
    inputs:
      mode:
        description: 'Release mode'
        required: true
        type: choice
        options:
          - full-release
          - docs-only
        default: 'full-release'

jobs:
  # Step 0: Run tests first
  test:
    uses: ./.github/workflows/test.yml

  release:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: write  # For creating releases and pushing commits
      id-token: write  # For PyPI Trusted Publisher OIDC
    env:
      PYTHON_VERSION: '3.7.9'
      PY_PREFIX: ${{ github.workspace }}/.local/python-3.7.9
      PIP_CACHE_DIR: ${{ github.workspace }}/.cache/pip
      RELEASE_MODE: ${{ inputs.mode }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Full history for changelog generation
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Ensure cache directories exist
      run: |
        mkdir -p "${{ env.PY_PREFIX }}" "${{ env.PIP_CACHE_DIR }}"

    - name: Restore Python build & pip caches
      id: python-cache
      uses: actions/cache@v4
      with:
        path: |
          ${{ env.PY_PREFIX }}
          ${{ env.PIP_CACHE_DIR }}
        key: python-${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          python-${{ runner.os }}-${{ env.PYTHON_VERSION }}-

    - name: Install build dependencies
      if: steps.python-cache.outputs.cache-hit != 'true'
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential wget curl libssl-dev zlib1g-dev \
          libbz2-dev libreadline-dev libsqlite3-dev libncurses5-dev libgdbm-dev \
          libnss3-dev liblzma-dev libffi-dev uuid-dev

    - name: Build and install Python (only if cache miss)
      if: steps.python-cache.outputs.cache-hit != 'true'
      run: |
        set -euo pipefail
        PY=${{ env.PYTHON_VERSION }}
        mkdir -p $HOME/src
        cd $HOME/src
        wget --no-verbose https://www.python.org/ftp/python/${PY}/Python-${PY}.tgz
        tar xzf Python-${PY}.tgz
        cd Python-${PY}
        ./configure --prefix=$PY_PREFIX --with-ensurepip=install
        make -j "$(nproc)"
        make install     

    - name: Add built Python to PATH
      run: |
        echo "${{ env.PY_PREFIX }}/bin" >> $GITHUB_PATH

    - name: Verify Python
      run: |
        python3 --version
        python3 -m pip --version

    - name: Install dependencies
      run: |
        python3 -m pip install --upgrade pip setuptools wheel twine
        if [ -f requirements.txt ]; then python3 -m pip install -r requirements.txt; fi

    # Step 2: Get version and create release branch
    - name: Get current version
      id: version
      run: |
        VERSION=$(grep "^version = " setup.cfg | sed 's/version = //')
        echo "Current version: $VERSION"
        
        # Remove .devN suffix if present
        RELEASE_VERSION=$(echo "$VERSION" | sed 's/\.dev[0-9]*$//')
        echo "Release version: $RELEASE_VERSION"
        
        # Store for later steps
        echo "version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
        echo "previous_version=$VERSION" >> $GITHUB_OUTPUT

    - name: Create release branch
      if: env.RELEASE_MODE == 'full-release'
      run: |
        TAG="v${{ steps.version.outputs.version }}"
        BRANCH_NAME="release/${TAG}"
        
        echo "Creating release branch: ${BRANCH_NAME}"
        git checkout -b "${BRANCH_NAME}"
        git push origin "${BRANCH_NAME}"

    # Step 3: Remove .dev suffix from version on release branch
    - name: Remove .dev suffix from version
      if: env.RELEASE_MODE == 'full-release'
      run: |
        RELEASE_VERSION="${{ steps.version.outputs.version }}"
        
        # Update setup.cfg
        sed -i "s/^version = .*/version = $RELEASE_VERSION/" setup.cfg
        
        echo "Updated setup.cfg to version $RELEASE_VERSION"
        
        git add setup.cfg
        git commit -m "Release version $RELEASE_VERSION [skip ci]"

    # Step 4: Generate changelog on release branch
    - name: Get previous release tag
      if: env.RELEASE_MODE == 'full-release'
      id: prev_tag
      run: |
        # Get the second-to-last tag (previous release)
        PREV_TAG=$(git tag --sort=-v:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sed -n '1p' || echo "")
        if [ -z "$PREV_TAG" ]; then
          echo "No previous release found, this is the first release"
          echo "prev_tag=" >> $GITHUB_OUTPUT
          echo "is_first=true" >> $GITHUB_OUTPUT
        else
          echo "Previous release tag: $PREV_TAG"
          echo "prev_tag=$PREV_TAG" >> $GITHUB_OUTPUT
          echo "is_first=false" >> $GITHUB_OUTPUT
        fi

    - name: Generate changelog with AI
      if: env.RELEASE_MODE == 'full-release' && steps.prev_tag.outputs.is_first != 'true'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        PREV_TAG="${{ steps.prev_tag.outputs.prev_tag }}"
        CURRENT_TAG="v${{ steps.version.outputs.version }}"
        
        # Get the diff statistics and commit messages
        echo "Analysing changes from ${PREV_TAG} to HEAD..."
        
        # Get diff stats
        DIFF_STATS=$(git diff --stat ${PREV_TAG}..HEAD)
        
        # Get commit messages with details
        COMMITS=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
        
        # Get changed files
        CHANGED_FILES=$(git diff --name-only ${PREV_TAG}..HEAD | head -20)
        
        # Create a prompt for the AI to summarize
        cat > /tmp/changelog_prompt.txt <<EOF
        Generate a concise, user-friendly changelog for version ${{ steps.version.outputs.version }} of the spafw37 Python framework.
        
        Review the following information and create a changelog that:
        1. Groups changes into categories (Added, Changed, Fixed, Removed, etc.)
        2. Uses clear, non-technical language where possible
        3. Highlights the most important changes first
        4. Keeps each bullet point concise (one line)
        5. Omits trivial changes like formatting or typos unless significant
        
        Commit messages:
        ${COMMITS}
        
        Changed files:
        ${CHANGED_FILES}
        
        Diff statistics:
        ${DIFF_STATS}
        
        Format the output as markdown suitable for a CHANGELOG.md file, starting with the changes (no header).
        EOF
        
        # Use GitHub Copilot API or fallback to structured commit list
        # Try to use gh cli with copilot extension if available
        if command -v gh &> /dev/null && gh copilot --version &> /dev/null 2>&1; then
          echo "Using GitHub Copilot to generate changelog..."
          CHANGELOG_CONTENT=$(gh copilot suggest "$(cat /tmp/changelog_prompt.txt)" 2>/dev/null || echo "")
        fi
        
        # Fallback: Use OpenAI API if OPENAI_API_KEY is set
        if [ -z "$CHANGELOG_CONTENT" ] && [ -n "${{ secrets.OPENAI_API_KEY }}" ]; then
          echo "Using OpenAI API to generate changelog..."
          CHANGELOG_CONTENT=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.OPENAI_API_KEY }}" \
            -d "{
              \"model\": \"gpt-4\",
              \"messages\": [{\"role\": \"user\", \"content\": $(jq -Rs . < /tmp/changelog_prompt.txt)}],
              \"temperature\": 0.3,
              \"max_tokens\": 1000
            }" | jq -r '.choices[0].message.content' 2>/dev/null || echo "")
        fi
        
        # Final fallback: Use structured commit list
        if [ -z "$CHANGELOG_CONTENT" ]; then
          echo "Using structured commit list (AI not available)..."
          CHANGELOG_CONTENT="### Changes

        ${COMMITS}
        
        *For detailed changes, see the [commit history](https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${CURRENT_TAG}).*"
        fi
        
        # Build the new changelog
        echo "# Changelog" > CHANGELOG.new.md
        echo "" >> CHANGELOG.new.md
        echo "## [${{ steps.version.outputs.version }}] - $(date +%Y-%m-%d)" >> CHANGELOG.new.md
        echo "" >> CHANGELOG.new.md
        echo "${CHANGELOG_CONTENT}" >> CHANGELOG.new.md
        echo "" >> CHANGELOG.new.md
        
        # Append existing changelog if it exists
        if [ -f CHANGELOG.md ]; then
          tail -n +2 CHANGELOG.md >> CHANGELOG.new.md
        fi
        
        mv CHANGELOG.new.md CHANGELOG.md
        
        echo "Changelog generated successfully"

    - name: Create initial changelog
      if: env.RELEASE_MODE == 'full-release' && steps.prev_tag.outputs.is_first == 'true'
      run: |
        echo "# Changelog" > CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "## [${{ steps.version.outputs.version }}] - $(date +%Y-%m-%d)" >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "Initial release" >> CHANGELOG.md
        echo "" >> CHANGELOG.md

    - name: Commit changelog
      if: env.RELEASE_MODE == 'full-release'
      run: |
        git add CHANGELOG.md
        git commit -m "Update CHANGELOG.md for v${{ steps.version.outputs.version }} [skip ci]" || echo "No changelog changes to commit"
        
        # Push release branch with version and changelog changes
        TAG="v${{ steps.version.outputs.version }}"
        git push origin "release/${TAG}"

    # Step 5: Update README links to point to tagged versions (separate commit, not merged to main)
    - name: Update README links to tagged documentation
      if: env.RELEASE_MODE == 'full-release'
      run: |
        TAG="v${{ steps.version.outputs.version }}"
        
        echo "Updating README.md links from /main/ to /${TAG}/"
        
        # Replace /tree/main/ with /tree/${TAG}/
        sed -i "s|/tree/main/|/tree/${TAG}/|g" README.md
        
        # Replace /blob/main/ with /blob/${TAG}/
        sed -i "s|/blob/main/|/blob/${TAG}/|g" README.md
        
        # Commit the README changes (this commit won't be merged to main)
        git add README.md
        git commit -m "Update README links to ${TAG} for tag [skip ci]" || echo "No README changes to commit"
        
        # Push this commit to release branch
        git push origin "release/${TAG}"

    # Step 6: Create git tag from release branch (includes README with tagged links)
    - name: Create git tag
      if: env.RELEASE_MODE == 'full-release'
      run: |
        # Tag is created from current branch (release/vX.Y.Z) which has README with tagged links
        git tag -a "v${{ steps.version.outputs.version }}" -m "Release v${{ steps.version.outputs.version }} [skip ci]"
        git push origin "v${{ steps.version.outputs.version }}"

    # Step 7: Create bugfix branch from tag
    - name: Create bugfix branch from tag
      if: env.RELEASE_MODE == 'full-release'
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        # Parse version to get major.minor (e.g., 1.0.0 -> 1.0)
        IFS='.' read -r major minor patch <<< "$VERSION"
        BRANCH_NAME="bugfix/${major}.${minor}.x"
        
        echo "Creating bugfix branch: $BRANCH_NAME"
        
        # Create branch from the tag
        git checkout -b "$BRANCH_NAME" "v${{ steps.version.outputs.version }}"
        
        # Push the branch
        git push origin "$BRANCH_NAME"

    # Step 8: Merge release branch back to main (without README link changes)
    - name: Merge release branch to main
      if: env.RELEASE_MODE == 'full-release'
      run: |
        TAG="v${{ steps.version.outputs.version }}"
        
        # Checkout main
        git checkout main
        git pull origin main
        
        # Merge release branch, stopping before the README commit
        # We want version and changelog changes, but not README link changes
        git merge "release/${TAG}~1" --no-ff -m "Merge release ${TAG} to main [skip ci]"
        
        # Push to main
        git push origin main

    # Step 9: Publish to PyPI using Trusted Publisher (OIDC)
    - name: Build distribution packages
      run: |
        python3 -m pip install --upgrade build
        # Build both source distribution and wheel explicitly
        python3 -m build --sdist --wheel

    - name: List distribution artifacts
      run: |
        echo "Built files in dist/"
        ls -la dist || true

    # Guard: ensure both a universal wheel and a source distribution are present
    # This prevents publishing when packaging omitted one of the expected artifacts.
    - name: Verify distribution artifacts and metadata
      run: |
        set -euo pipefail

        echo "Checking for wheel and sdist in dist/"

        # Pick a wheel to inspect. Prefer wheels with py3 tags.
        WHEEL=$(ls dist/*.whl 2>/dev/null | grep -E 'py3-none-any|py2.py3-none-any|py3-none-any' | head -n1 || true)
        if [ -z "$WHEEL" ]; then
          WHEEL=$(ls dist/*.whl 2>/dev/null | head -n1 || true)
        fi

        if [ -z "$WHEEL" ]; then
          echo "ERROR: No wheel file found in dist/"
          ls -la dist || true
          exit 1
        fi

        echo "Inspecting wheel: $WHEEL"

        # Extract METADATA from the wheel and check Requires-Python
        TMPDIR=$(mktemp -d)
        unzip -q "$WHEEL" -d "$TMPDIR"
        META=$(find "$TMPDIR" -type f -name METADATA -print -quit || true)
        if [ -z "$META" ]; then
          echo "ERROR: Could not find METADATA inside wheel: $WHEEL"
          ls -la "$TMPDIR" || true
          rm -rf "$TMPDIR"
          exit 1
        fi

        echo "METADATA excerpt:"
        grep -i '^Requires-Python:' "$META" || true

        REQUIRES_PYTHON=$(grep -i '^Requires-Python:' "$META" | sed 's/[Rr]equires-[Pp]ython:\s*//') || true
        if [ -z "$REQUIRES_PYTHON" ]; then
          echo "ERROR: Wheel METADATA does not include a Requires-Python field; expected '>=3.7'"
          rm -rf "$TMPDIR"
          exit 1
        fi

        echo "Requires-Python: $REQUIRES_PYTHON"

        # Basic check that the wheel advertises Python 3.7+ support
        echo "$REQUIRES_PYTHON" | grep -E '>= *3\.7|3\.7' >/dev/null 2>&1 || {
          echo "ERROR: Wheel does not advertise Python >=3.7 in Requires-Python: $REQUIRES_PYTHON"
          rm -rf "$TMPDIR"
          exit 1
        }

        rm -rf "$TMPDIR"

        if ls dist/*.tar.gz 1> /dev/null 2>&1; then
          echo "Found sdist (.tar.gz)"
        else
          echo "ERROR: No source distribution (.tar.gz) found in dist/"
          ls -la dist || true
          exit 1
        fi

    - name: Publish to PyPI
      id: pypi_publish
      continue-on-error: true
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        skip-existing: true

    # Step 10: Increment version and add .dev0 suffix for next development cycle
    - name: Increment version for next development cycle
      if: env.RELEASE_MODE == 'full-release'
      id: next_version
      run: |
        # Ensure we're on main
        git checkout main
        git pull origin main
        
        VERSION="${{ steps.version.outputs.version }}"
        echo "Current release version: $VERSION"
        
        # Parse version components (X.Y.Z)
        IFS='.' read -r major minor patch <<< "$VERSION"
        
        # Increment patch version
        next_patch=$((patch + 1))
        NEXT_VERSION="${major}.${minor}.${next_patch}.dev0"
        
        echo "Next development version: $NEXT_VERSION"
        echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
        
        # Update setup.cfg
        sed -i "s/^version = .*/version = $NEXT_VERSION/" setup.cfg

    # Step 11: Commit dev version and create GitHub Release
    - name: Commit development version
      if: env.RELEASE_MODE == 'full-release'
      run: |
        git add setup.cfg
        git commit -m "Bump version to ${{ steps.next_version.outputs.next_version }} [skip ci]"
        git push origin main

    # Create GitHub Release
    - name: Create GitHub Release
      if: env.RELEASE_MODE == 'full-release'
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ steps.version.outputs.version }}
        release_name: Release v${{ steps.version.outputs.version }}
        body: |
          Release of spafw37 version ${{ steps.version.outputs.version }}
          
          Install with:
          ```
          pip install spafw37==${{ steps.version.outputs.version }}
          ```
          
          See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for details.
        draft: false
        prerelease: false

    # Summary of what happened
    - name: Release Summary
      if: always()
      run: |
        echo "## Release Workflow Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Mode:** ${{ env.RELEASE_MODE }}" >> $GITHUB_STEP_SUMMARY
        echo "**Version:** ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ env.RELEASE_MODE }}" == "full-release" ]; then
          echo "### Full Release Process" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.pypi_publish.outcome }}" == "success" ]; then
            echo "✅ **PyPI Publish:** Success" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.pypi_publish.outcome }}" == "failure" ]; then
            echo "⚠️  **PyPI Publish:** Failed (version may already exist)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
            echo "- Check if version already exists on PyPI" >> $GITHUB_STEP_SUMMARY
            echo "- If documentation needs updating, run workflow again with 'docs-only' mode" >> $GITHUB_STEP_SUMMARY
            echo "- For code changes, create a new patch release" >> $GITHUB_STEP_SUMMARY
          else
            echo "⏭️  **PyPI Publish:** Skipped or cancelled" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Actions Completed:**" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Created release branch \`release/v${{ steps.version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Updated version in setup.cfg" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Generated/updated CHANGELOG.md" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Created git tag \`v${{ steps.version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Created bugfix branch" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Merged changes to main" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Bumped version to \`${{ steps.next_version.outputs.next_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Created GitHub Release" >> $GITHUB_STEP_SUMMARY
        else
          echo "### Documentation-Only Update" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.pypi_publish.outcome }}" == "success" ]; then
            echo "✅ **PyPI Documentation:** Successfully updated" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The package metadata and long description on PyPI have been refreshed." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Note:** PyPI may take a few minutes to display the updated documentation." >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **PyPI Documentation:** Update failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The documentation update could not be completed. This usually means:" >> $GITHUB_STEP_SUMMARY
            echo "- The package version doesn't exist on PyPI yet" >> $GITHUB_STEP_SUMMARY
            echo "- There was a problem with the PyPI upload" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Actions Completed:**" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Built package with current documentation" >> $GITHUB_STEP_SUMMARY
          echo "- ⏭️  Skipped git operations (no tags/branches created)" >> $GITHUB_STEP_SUMMARY
          echo "- ⏭️  Skipped version bumps" >> $GITHUB_STEP_SUMMARY
        fi
